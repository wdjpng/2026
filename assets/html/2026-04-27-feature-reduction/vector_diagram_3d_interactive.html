<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Vector Diagram</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(45, 45, 45, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: #aaa;
            font-size: 14px;
            max-width: 300px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .instructions h3 {
            margin: 0 0 10px 0;
            color: #fff;
        }
        .instructions ul {
            margin: 5px 0;
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="instructions">
        <h3>3D Vector Controls</h3>
        <ul>
            <li><strong>Rotate view:</strong> Left click + drag</li>
            <li><strong>Move vectors:</strong> Click sphere + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel</li>
            <li><strong>Pan:</strong> Right click + drag</li>
        </ul>
        <div style="margin-top: 10px;">
            <div><span style="color: #1DA37E;">●</span> Vector 1 (Green)</div>
            <div><span style="color: #A75F9A;">●</span> Vector 2 (Purple)</div>
            <div><span style="color: #AA6600;">●</span> Vector 3 (Orange)</div>
            <div><span style="color: #4AACE2;">●</span> Vector 4 (Blue)</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e1e1e);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.4);
        pointLight.position.set(-5, -5, -5);
        scene.add(pointLight);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x333333);
        scene.add(gridHelper);
        
        // Axes helper
        const axesHelper = new THREE.AxesHelper(4);
        scene.add(axesHelper);
        
        // Orbit controls (simplified version)
        let isRotating = false;
        let isDraggingVector = false;
        let previousMousePosition = { x: 0, y: 0 };
        let activeVector = null;
        
        // Vector configuration
        const vectorLength = 3;
        const sphereRadius = 0.15;
        const colors = {
            vector1: 0x1DA37E,  // Green
            vector2: 0xA75F9A,  // Purple
            vector3: 0xAA6600,  // Orange
            vector4: 0x4AACE2   // Blue (new vector)
        };
        
        // Vector directions (normalized)
        const vectors = {
            vector1: new THREE.Vector3(1, 0, 0),
            vector2: new THREE.Vector3(0, 1, 0),
            vector3: new THREE.Vector3(-0.7, -0.7, 0).normalize(),
            vector4: new THREE.Vector3(0.5, 0.5, 0.7).normalize()
        };
        
        // Store vector objects
        const vectorObjects = {};
        const sphereObjects = {};
        const combinationVectors = [];
        const shadedRegions = [];
        
        // Create a vector with arrow
        function createVector(direction, color, name) {
            const group = new THREE.Group();
            
            // Arrow shaft
            const shaftGeometry = new THREE.CylinderGeometry(0.03, 0.03, vectorLength, 16);
            const shaftMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.2
            });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            
            // Arrow head (cone)
            const coneGeometry = new THREE.ConeGeometry(0.1, 0.3, 16);
            const coneMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            
            // Position arrow head at the tip
            cone.position.y = vectorLength / 2 + 0.15;
            shaft.position.y = vectorLength / 2;
            
            group.add(shaft);
            group.add(cone);
            
            // Create interactive sphere at the tip
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 32, 32);
            const sphereMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.4,
                shininess: 100
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.y = vectorLength;
            sphere.userData = { vectorName: name, isDraggable: true };
            group.add(sphere);
            
            // Orient the group in the direction
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
            group.setRotationFromQuaternion(quaternion);
            
            scene.add(group);
            
            vectorObjects[name] = group;
            sphereObjects[name] = sphere;
            
            return group;
        }
        
        // Create combination vector (dashed line between two vectors)
        function createCombinationVector(vec1Name, vec2Name) {
            const color1 = vectorObjects[vec1Name].children[0].material.color;
            const color2 = vectorObjects[vec2Name].children[0].material.color;
            
            // Average color
            const avgColor = new THREE.Color(
                (color1.r + color2.r) / 2,
                (color1.g + color2.g) / 2,
                (color1.b + color2.b) / 2
            );
            
            const material = new THREE.LineDashedMaterial({
                color: avgColor,
                linewidth: 2,
                dashSize: 0.1,
                gapSize: 0.05,
                opacity: 0.7,
                transparent: true
            });
            
            const geometry = new THREE.BufferGeometry();
            const line = new THREE.Line(geometry, material);
            line.userData = { vec1Name, vec2Name, isCombination: true };
            
            scene.add(line);
            combinationVectors.push(line);
            
            return line;
        }
        
        // Update combination vector positions
        function updateCombinationVectors() {
            combinationVectors.forEach(line => {
                const vec1 = vectors[line.userData.vec1Name];
                const vec2 = vectors[line.userData.vec2Name];
                
                // Average direction
                const avgDir = vec1.clone().add(vec2).normalize();
                const endPoint = avgDir.multiplyScalar(vectorLength);
                
                const positions = new Float32Array([
                    0, 0, 0,
                    endPoint.x, endPoint.y, endPoint.z
                ]);
                
                line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                line.geometry.computeBoundingSphere();
                line.computeLineDistances();
            });
        }
        
        // Create shaded region between center, a vector, and a combination vector
        function createShadedTriangle(vectorName, combo1Name, combo2Name, color) {
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = { vectorName, combo1Name, combo2Name, isShadedRegion: true };
            scene.add(mesh);
            shadedRegions.push(mesh);
            
            return mesh;
        }
        
        // Update all shaded regions
        function updateShadedRegions() {
            shadedRegions.forEach(mesh => {
                const { vectorName, combo1Name, combo2Name } = mesh.userData;
                
                // Get the main vector direction
                const mainVec = vectors[vectorName].clone().multiplyScalar(vectorLength);
                
                // Get the two combination vectors
                const combo1 = getCombinationDirection(combo1Name).multiplyScalar(vectorLength);
                const combo2 = getCombinationDirection(combo2Name).multiplyScalar(vectorLength);
                
                // Create triangle from origin to main vector to combo vectors
                const positions = new Float32Array([
                    0, 0, 0,
                    mainVec.x, mainVec.y, mainVec.z,
                    combo1.x, combo1.y, combo1.z,
                    
                    0, 0, 0,
                    mainVec.x, mainVec.y, mainVec.z,
                    combo2.x, combo2.y, combo2.z
                ]);
                
                mesh.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                mesh.geometry.computeVertexNormals();
            });
        }
        
        // Helper to get combination direction
        function getCombinationDirection(comboName) {
            const combo = comboName.split('-');
            const vec1 = vectors[combo[0]];
            const vec2 = vectors[combo[1]];
            return vec1.clone().add(vec2).normalize();
        }
        
        // Update vector direction
        function updateVector(name, newDirection) {
            vectors[name].copy(newDirection.normalize());
            const group = vectorObjects[name];
            
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), vectors[name]);
            group.setRotationFromQuaternion(quaternion);
        }
        
        // Create all vectors
        createVector(vectors.vector1, colors.vector1, 'vector1');
        createVector(vectors.vector2, colors.vector2, 'vector2');
        createVector(vectors.vector3, colors.vector3, 'vector3');
        createVector(vectors.vector4, colors.vector4, 'vector4');
        
        // Create combination vectors (all pairs)
        createCombinationVector('vector1', 'vector2');
        createCombinationVector('vector1', 'vector3');
        createCombinationVector('vector1', 'vector4');
        createCombinationVector('vector2', 'vector3');
        createCombinationVector('vector2', 'vector4');
        createCombinationVector('vector3', 'vector4');
        
        updateCombinationVectors();
        
        // Create shaded regions for each vector with its combinations
        // Vector 1 (green) with its three combinations
        createShadedTriangle('vector1', 'vector1-vector2', 'vector1-vector3', colors.vector1);
        createShadedTriangle('vector1', 'vector1-vector2', 'vector1-vector4', colors.vector1);
        createShadedTriangle('vector1', 'vector1-vector3', 'vector1-vector4', colors.vector1);
        
        // Vector 2 (purple) with its three combinations
        createShadedTriangle('vector2', 'vector1-vector2', 'vector2-vector3', colors.vector2);
        createShadedTriangle('vector2', 'vector1-vector2', 'vector2-vector4', colors.vector2);
        createShadedTriangle('vector2', 'vector2-vector3', 'vector2-vector4', colors.vector2);
        
        // Vector 3 (orange) with its three combinations
        createShadedTriangle('vector3', 'vector1-vector3', 'vector2-vector3', colors.vector3);
        createShadedTriangle('vector3', 'vector1-vector3', 'vector3-vector4', colors.vector3);
        createShadedTriangle('vector3', 'vector2-vector3', 'vector3-vector4', colors.vector3);
        
        // Vector 4 (blue) with its three combinations
        createShadedTriangle('vector4', 'vector1-vector4', 'vector2-vector4', colors.vector4);
        createShadedTriangle('vector4', 'vector1-vector4', 'vector3-vector4', colors.vector4);
        createShadedTriangle('vector4', 'vector2-vector4', 'vector3-vector4', colors.vector4);
        
        updateShadedRegions();
        
        // Raycasting for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseDown(event) {
            if (event.button !== 0) return; // Only left click
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const spheres = Object.values(sphereObjects);
            const intersects = raycaster.intersectObjects(spheres);
            
            if (intersects.length > 0) {
                isDraggingVector = true;
                activeVector = intersects[0].object.userData.vectorName;
                event.preventDefault();
            } else {
                isRotating = true;
            }
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        function onMouseMove(event) {
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            
            if (isDraggingVector && activeVector) {
                // Get the mouse position in normalized device coordinates
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Create a plane perpendicular to the camera
                const planeNormal = camera.position.clone().normalize();
                const plane = new THREE.Plane(planeNormal, 0);
                
                raycaster.setFromCamera(mouse, camera);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);
                
                if (intersectPoint) {
                    // Update vector direction
                    const newDirection = intersectPoint.clone().normalize();
                    updateVector(activeVector, newDirection);
                    updateCombinationVectors();
                    updateShadedRegions();
                }
            } else if (isRotating) {
                // Rotate camera around origin
                const rotationSpeed = 0.005;
                
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                
                spherical.theta -= deltaX * rotationSpeed;
                spherical.phi -= deltaY * rotationSpeed;
                
                // Clamp phi to avoid gimbal lock
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
            }
            
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }
        
        function onMouseUp() {
            isRotating = false;
            isDraggingVector = false;
            activeVector = null;
        }
        
        function onWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.1;
            const delta = event.deltaY > 0 ? 1 : -1;
            
            camera.position.multiplyScalar(1 + delta * zoomSpeed);
            
            // Clamp distance
            const distance = camera.position.length();
            if (distance < 2) {
                camera.position.normalize().multiplyScalar(2);
            } else if (distance > 20) {
                camera.position.normalize().multiplyScalar(20);
            }
        }
        
        // Event listeners
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
