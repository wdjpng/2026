<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchical Graph Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background-color: #0f172a;
            color: #f1f5f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 1.5rem;
            max-width: 48rem;
        }

        h1 {
            font-size: 1.875rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: #cbd5e1;
            margin-bottom: 0.5rem;
        }

        .instructions {
            color: #94a3b8;
            font-size: 0.875rem;
            margin-bottom: 1rem;
        }

        .controls {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        button {
            padding: 0.5rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }

        .btn-primary {
            background-color: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background-color: #2563eb;
        }

        .btn-secondary {
            background-color: #8b5cf6;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #7c3aed;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #1e293b;
            border-radius: 0.5rem;
            padding: 0.25rem;
        }

        .control-label {
            color: #cbd5e1;
            font-size: 0.875rem;
            padding: 0 0.5rem;
        }

        .control-group button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            background-color: #334155;
            color: #cbd5e1;
        }

        .control-group button:hover {
            background-color: #475569;
        }

        .control-group button.active {
            background-color: #10b981;
            color: white;
        }

        .control-group button.active-blue {
            background-color: #3b82f6;
            color: white;
        }

        .control-group button.active-purple {
            background-color: #8b5cf6;
            color: white;
        }

        .control-group button.active-pink {
            background-color: #ec4899;
            color: white;
        }

        .control-group button.active-amber {
            background-color: #f59e0b;
            color: white;
        }

        .canvas-container {
            background-color: #1e293b;
            border-radius: 0.5rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            margin-bottom: 1.5rem;
        }

        #canvas3d {
            display: block;
            cursor: grab;
        }

        #canvas3d:active {
            cursor: grabbing;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .legend-nodes {
            display: flex;
            gap: 1.5rem;
            font-size: 0.875rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .color-circle {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
        }

        .legend-info {
            text-align: center;
            font-size: 0.875rem;
        }

        .legend-title {
            color: #cbd5e1;
            margin-bottom: 0.25rem;
        }

        .legend-subtitle {
            color: #94a3b8;
            font-size: 0.75rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Hierarchical Graph Visualization</h1>
        <p class="subtitle">Four-layer hierarchy: 4 base nodes → 6 pairs → 4 triples → 1 complete union</p>
        <p class="instructions">Click nodes to toggle • Drag to rotate • Deactivating base nodes cascades up</p>
        
        <div class="controls">
            <button class="btn-primary" onclick="toggleAllNodes()">Toggle All Nodes</button>
            <button class="btn-secondary" onclick="resetPositions()">Reset Positions</button>
            
            <div class="control-group">
                <span class="control-label">Edge Connections:</span>
                <button id="skip0" class="active" onclick="setEdgeSkip(0)">Adjacent Only</button>
                <button id="skip1" onclick="setEdgeSkip(1)">+ Skip 1 Layer</button>
                <button id="skip2" onclick="setEdgeSkip(2)">+ Skip 2 Layers</button>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <span class="control-label">Show Edges From:</span>
                <button id="edge1" class="active-blue" onclick="toggleEdgeLayer(1)">Layer 1</button>
                <button id="edge2" class="active-purple" onclick="toggleEdgeLayer(2)">Layer 2</button>
                <button id="edge3" class="active-pink" onclick="toggleEdgeLayer(3)">Layer 3</button>
            </div>

            <div class="control-group">
                <span class="control-label">Show Nodes:</span>
                <button id="node1" class="active-blue" onclick="toggleNodeLayer(1)">Layer 1</button>
                <button id="node2" class="active-purple" onclick="toggleNodeLayer(2)">Layer 2</button>
                <button id="node3" class="active-pink" onclick="toggleNodeLayer(3)">Layer 3</button>
                <button id="node4" class="active-amber" onclick="toggleNodeLayer(4)">Layer 4</button>
            </div>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="canvas3d" width="900" height="700"></canvas>
    </div>

    <div class="legend">
        <div class="legend-nodes">
            <div class="legend-item">
                <div class="color-circle" style="background-color: #0173B2;"></div>
                <span><strong>Node A</strong></span>
            </div>
            <div class="legend-item">
                <div class="color-circle" style="background-color: #DE8F05;"></div>
                <span><strong>Node B</strong></span>
            </div>
            <div class="legend-item">
                <div class="color-circle" style="background-color: #029E73;"></div>
                <span><strong>Node C</strong></span>
            </div>
            <div class="legend-item">
                <div class="color-circle" style="background-color: #CC78BC;"></div>
                <span><strong>Node D</strong></span>
            </div>
        </div>
        <div class="legend-info">
            <div class="legend-title" id="legendTitle">Adjacent layers only</div>
            <div class="legend-subtitle" id="legendSubtitle">Edge sources: L1, L2, L3 • Visible nodes: L1, L2, L3, L4</div>
        </div>
    </div>

    <script>
        // Global state
        let nodeData = [
            // Layer 1: Base nodes
            { id: 0, layer: 1, x: -3, y: -2.5, z: -3, vx: 0, vy: 0, vz: 0, active: true, composedOf: [], label: 'A' },
            { id: 1, layer: 1, x: 3, y: -2.5, z: -3, vx: 0, vy: 0, vz: 0, active: true, composedOf: [], label: 'B' },
            { id: 2, layer: 1, x: 3, y: -2.5, z: 3, vx: 0, vy: 0, vz: 0, active: true, composedOf: [], label: 'C' },
            { id: 3, layer: 1, x: -3, y: -2.5, z: 3, vx: 0, vy: 0, vz: 0, active: true, composedOf: [], label: 'D' },
            
            // Layer 2: Pairwise combinations
            { id: 4, layer: 2, x: 0, y: 0.2, z: -3.5, vx: 0, vy: 0, vz: 0, active: true, composedOf: [0, 1], label: 'A∪B' },
            { id: 5, layer: 2, x: 3.5, y: 0.2, z: 0, vx: 0, vy: 0, vz: 0, active: true, composedOf: [1, 2], label: 'B∪C' },
            { id: 6, layer: 2, x: 0, y: 0.2, z: 3.5, vx: 0, vy: 0, vz: 0, active: true, composedOf: [2, 3], label: 'C∪D' },
            { id: 7, layer: 2, x: -3.5, y: 0.2, z: 0, vx: 0, vy: 0, vz: 0, active: true, composedOf: [0, 3], label: 'A∪D' },
            { id: 8, layer: 2, x: 2.5, y: 0.2, z: -2.5, vx: 0, vy: 0, vz: 0, active: true, composedOf: [0, 2], label: 'A∪C' },
            { id: 9, layer: 2, x: -2.5, y: 0.2, z: 2.5, vx: 0, vy: 0, vz: 0, active: true, composedOf: [1, 3], label: 'B∪D' },
            
            // Layer 3: Triple combinations
            { id: 10, layer: 3, x: 1.5, y: 2.6, z: -1.5, vx: 0, vy: 0, vz: 0, active: true, composedOf: [0, 1, 2], label: 'A∪B∪C' },
            { id: 11, layer: 3, x: -1.5, y: 2.6, z: -1.5, vx: 0, vy: 0, vz: 0, active: true, composedOf: [0, 1, 3], label: 'A∪B∪D' },
            { id: 12, layer: 3, x: 1.5, y: 2.6, z: 1.5, vx: 0, vy: 0, vz: 0, active: true, composedOf: [1, 2, 3], label: 'B∪C∪D' },
            { id: 13, layer: 3, x: -1.5, y: 2.6, z: 1.5, vx: 0, vy: 0, vz: 0, active: true, composedOf: [0, 2, 3], label: 'A∪C∪D' },
            
            // Layer 4: Complete combination
            { id: 14, layer: 4, x: 0, y: 5.4, z: 0, vx: 0, vy: 0, vz: 0, active: true, composedOf: [0, 1, 2, 3], label: 'A∪B∪C∪D' },
        ];

        let hoveredNode = null;
        let edgeSkipLayers = 0;
        let activeLayers = [1, 2, 3];
        let visibleNodeLayers = [1, 2, 3, 4];

        const BASE_COLORS = {
            A: 0x0173B2,
            B: 0xDE8F05,
            C: 0x029E73,
            D: 0xCC78BC,
        };

        const allEdgesBySkip = {
            0: [
                { from: 0, to: 4 }, { from: 1, to: 4 }, { from: 1, to: 5 }, { from: 2, to: 5 },
                { from: 2, to: 6 }, { from: 3, to: 6 }, { from: 0, to: 7 }, { from: 3, to: 7 },
                { from: 0, to: 8 }, { from: 2, to: 8 }, { from: 1, to: 9 }, { from: 3, to: 9 },
                { from: 4, to: 10 }, { from: 5, to: 10 }, { from: 8, to: 10 },
                { from: 4, to: 11 }, { from: 7, to: 11 }, { from: 9, to: 11 },
                { from: 5, to: 12 }, { from: 6, to: 12 }, { from: 9, to: 12 },
                { from: 8, to: 13 }, { from: 6, to: 13 }, { from: 7, to: 13 },
                { from: 10, to: 14 }, { from: 11, to: 14 }, { from: 12, to: 14 }, { from: 13, to: 14 },
            ],
            1: [
                { from: 0, to: 10 }, { from: 1, to: 10 }, { from: 2, to: 10 },
                { from: 0, to: 11 }, { from: 1, to: 11 }, { from: 3, to: 11 },
                { from: 1, to: 12 }, { from: 2, to: 12 }, { from: 3, to: 12 },
                { from: 0, to: 13 }, { from: 2, to: 13 }, { from: 3, to: 13 },
                { from: 4, to: 14 }, { from: 5, to: 14 }, { from: 6, to: 14 },
                { from: 7, to: 14 }, { from: 8, to: 14 }, { from: 9, to: 14 },
            ],
            2: [
                { from: 0, to: 14 }, { from: 1, to: 14 }, { from: 2, to: 14 }, { from: 3, to: 14 },
            ]
        };

        const SPRING_LENGTH = 2.5;
        const SPRING_STRENGTH = 0.012;
        const REPULSION_STRENGTH = 1.2;
        const DAMPING = 0.85;
        const LAYER_SEPARATION = 2.2;

        let scene, camera, renderer;
        let nodeMeshes = [];
        let edgeLines = [];
        let raycaster, mouse;
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };

        function getNodeSize(layer) {
            switch (layer) {
                case 1: return 0.25;
                case 2: return 0.35;
                case 3: return 0.45;
                case 4: return 0.6;
                default: return 0.25;
            }
        }

        function getBaseColorById(nodeId) {
            const node = nodeData[nodeId];
            if (node.layer === 1) {
                return BASE_COLORS[node.label];
            }
            return 0x64748b;
        }

        function getEdgeColor(layer) {
            switch (layer) {
                case 1: return 0x3b82f6;
                case 2: return 0x8b5cf6;
                case 3: return 0xec4899;
                default: return 0x64748b;
            }
        }

        function createCompositeGeometry(node) {
            const group = new THREE.Group();
            
            if (node.layer === 1) {
                const size = getNodeSize(node.layer);
                const color = BASE_COLORS[node.label];
                const geometry = new THREE.SphereGeometry(size, 32, 32);
                const material = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
                const mesh = new THREE.Mesh(geometry, material);
                group.add(mesh);
                return group;
            }
            
            const componentCount = node.composedOf.length;
            const sphereSize = 0.15;
            
            node.composedOf.forEach((componentId, idx) => {
                const componentColor = getBaseColorById(componentId);
                const geometry = new THREE.SphereGeometry(sphereSize, 24, 24);
                const material = new THREE.MeshPhongMaterial({ color: componentColor, shininess: 100 });
                const mesh = new THREE.Mesh(geometry, material);
                
                if (componentCount === 2) {
                    mesh.position.set((idx - 0.5) * sphereSize * 2.2, 0, 0);
                } else if (componentCount === 3) {
                    const angle = (idx / 3) * Math.PI * 2 - Math.PI / 2;
                    const radius = sphereSize * 1.5;
                    mesh.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
                } else if (componentCount === 4) {
                    const positions = [
                        [-sphereSize * 1.1, -sphereSize * 1.1, 0],
                        [sphereSize * 1.1, -sphereSize * 1.1, 0],
                        [sphereSize * 1.1, sphereSize * 1.1, 0],
                        [-sphereSize * 1.1, sphereSize * 1.1, 0],
                    ];
                    mesh.position.set(positions[idx][0], positions[idx][1], positions[idx][2]);
                }
                
                group.add(mesh);
            });
            
            return group;
        }

        function getActiveEdges() {
            let edges = [];
            for (let skip = 0; skip <= edgeSkipLayers; skip++) {
                edges = edges.concat(allEdgesBySkip[skip]);
            }
            edges = edges.filter(edge => {
                const fromNode = nodeData[edge.from];
                return activeLayers.includes(fromNode.layer);
            });
            return edges;
        }

        function init() {
            const canvas = document.getElementById('canvas3d');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);

            camera = new THREE.PerspectiveCamera(70, 900 / 700, 0.1, 1000);
            camera.position.set(8, 3, 12);
            camera.lookAt(0, 1.5, 0);

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(900, 700);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 8, 5);
            scene.add(directionalLight);

            const backLight = new THREE.DirectionalLight(0x6366f1, 0.4);
            backLight.position.set(-5, -3, -5);
            scene.add(backLight);

            const topLight = new THREE.DirectionalLight(0xec4899, 0.3);
            topLight.position.set(0, 10, 0);
            scene.add(topLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createScene();
            setupEventListeners();
            animate();
        }

        function createScene() {
            // Clear existing
            nodeMeshes.forEach(mesh => scene.remove(mesh));
            edgeLines.forEach(line => scene.remove(line));
            nodeMeshes = [];
            edgeLines = [];

            // Create nodes
            nodeData.forEach((node) => {
                const nodeMesh = createCompositeGeometry(node);
                nodeMesh.position.set(node.x, node.y, node.z);
                nodeMesh.userData = { nodeId: node.id };
                nodeMesh.visible = visibleNodeLayers.includes(node.layer);
                scene.add(nodeMesh);
                nodeMeshes.push(nodeMesh);
            });

            // Create edges
            const edgeConnections = getActiveEdges();
            edgeConnections.forEach((edge) => {
                const fromNode = nodeData[edge.from];
                const edgeColor = getEdgeColor(fromNode.layer);
                const material = new THREE.LineBasicMaterial({ 
                    color: edgeColor,
                    linewidth: 2,
                    transparent: true,
                    opacity: 0.6
                });
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const line = new THREE.Line(geometry, material);
                line.userData = { from: edge.from, to: edge.to };
                scene.add(line);
                edgeLines.push(line);
            });
        }

        function setupEventListeners() {
            const canvas = document.getElementById('canvas3d');

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouse = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                if (isDragging) {
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;
                    
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.005);
                    
                    const right = new THREE.Vector3();
                    camera.getWorldDirection(right);
                    right.cross(camera.up).normalize();
                    camera.position.applyAxisAngle(right, deltaY * 0.005);
                    
                    camera.lookAt(0, 1.5, 0);
                    
                    previousMouse = { x: e.clientX, y: e.clientY };
                } else {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(nodeMeshes, true);
                    
                    if (intersects.length > 0) {
                        let obj = intersects[0].object;
                        while (obj.parent && obj.userData.nodeId === undefined) {
                            obj = obj.parent;
                        }
                        if (obj.userData.nodeId !== undefined) {
                            hoveredNode = obj.userData.nodeId;
                        } else {
                            hoveredNode = null;
                        }
                    } else {
                        hoveredNode = null;
                    }
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('click', (e) => {
                if (isDragging) return;

                const rect = canvas.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(nodeMeshes, true);

                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    while (obj.parent && obj.userData.nodeId === undefined) {
                        obj = obj.parent;
                    }
                    
                    if (obj.userData.nodeId !== undefined) {
                        const nodeId = obj.userData.nodeId;
                        nodeData[nodeId].active = !nodeData[nodeId].active;
                        
                        if (!nodeData[nodeId].active) {
                            nodeData.forEach(node => {
                                if (node.composedOf.includes(nodeId)) {
                                    node.active = false;
                                }
                            });
                        } else {
                            nodeData.forEach(node => {
                                if (node.composedOf.length > 0) {
                                    const allComponentsActive = node.composedOf.every(compId => nodeData[compId].active);
                                    if (allComponentsActive) {
                                        node.active = true;
                                    }
                                }
                            });
                        }
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Reset forces
            nodeData.forEach(node => {
                node.fx = 0;
                node.fy = 0;
                node.fz = 0;
            });

            // Apply layer separation force
            nodeData.forEach(node => {
                if (!node.active) return;
                const targetY = (node.layer - 1) * LAYER_SEPARATION - 2;
                const dy = targetY - node.y;
                node.fy += dy * 0.02;
            });

            // Spring forces
            const edgeConnections = getActiveEdges();
            edgeConnections.forEach(edge => {
                const fromNode = nodeData[edge.from];
                const toNode = nodeData[edge.to];
                
                if (!fromNode.active || !toNode.active) return;
                
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const dz = toNode.z - fromNode.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance === 0) return;
                
                const force = (distance - SPRING_LENGTH) * SPRING_STRENGTH;
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;
                const fz = (dz / distance) * force;
                
                fromNode.fx += fx;
                fromNode.fy += fy * 0.3;
                fromNode.fz += fz;
                toNode.fx -= fx;
                toNode.fy -= fy * 0.3;
                toNode.fz -= fz;
            });

            // Repulsion forces
            for (let i = 0; i < nodeData.length; i++) {
                if (!nodeData[i].active) continue;
                
                for (let j = i + 1; j < nodeData.length; j++) {
                    if (!nodeData[j].active) continue;
                    
                    const sameLay = nodeData[i].layer === nodeData[j].layer;
                    
                    const dx = nodeData[j].x - nodeData[i].x;
                    const dy = nodeData[j].y - nodeData[i].y;
                    const dz = nodeData[j].z - nodeData[i].z;
                    const distSq = dx * dx + dy * dy + dz * dz;
                    
                    if (distSq === 0) continue;
                    
                    const force = (sameLay ? REPULSION_STRENGTH * 2 : REPULSION_STRENGTH) / distSq;
                    const distance = Math.sqrt(distSq);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    const fz = (dz / distance) * force;
                    
                    nodeData[i].fx -= fx;
                    nodeData[i].fy -= fy * 0.2;
                    nodeData[i].fz -= fz;
                    nodeData[j].fx += fx;
                    nodeData[j].fy += fy * 0.2;
                    nodeData[j].fz += fz;
                }
            }

            // Update velocities and positions
            nodeData.forEach((node, idx) => {
                if (!node.active) return;
                
                node.vx = (node.vx + node.fx) * DAMPING;
                node.vy = (node.vy + node.fy) * DAMPING;
                node.vz = (node.vz + node.fz) * DAMPING;
                
                node.x += node.vx;
                node.y += node.vy;
                node.z += node.vz;
                
                nodeMeshes[idx].position.set(node.x, node.y, node.z);
            });

            // Update node appearance
            nodeMeshes.forEach((mesh, idx) => {
                const node = nodeData[idx];
                const isHovered = hoveredNode === node.id;
                
                mesh.visible = visibleNodeLayers.includes(node.layer);
                mesh.scale.setScalar(isHovered ? 1.3 : 1);
                
                if (node.composedOf.length > 0) {
                    mesh.rotation.y += 0.008;
                }
                
                mesh.children.forEach(child => {
                    if (child instanceof THREE.Mesh && child.material) {
                        child.material.opacity = node.active ? 1.0 : 0.3;
                        child.material.transparent = !node.active;
                    }
                });
            });

            // Update edges
            edgeLines.forEach(line => {
                const fromNode = nodeData[line.userData.from];
                const toNode = nodeData[line.userData.to];
                
                const positions = line.geometry.attributes.position.array;
                positions[0] = fromNode.x;
                positions[1] = fromNode.y;
                positions[2] = fromNode.z;
                positions[3] = toNode.x;
                positions[4] = toNode.y;
                positions[5] = toNode.z;
                line.geometry.attributes.position.needsUpdate = true;
                
                const bothNodesVisible = visibleNodeLayers.includes(fromNode.layer) && 
                                          visibleNodeLayers.includes(toNode.layer);
                line.visible = fromNode.active && toNode.active && bothNodesVisible;
                line.material.opacity = (fromNode.active && toNode.active && bothNodesVisible) ? 0.6 : 0.2;
            });

            renderer.render(scene, camera);
        }

        function updateLegend() {
            const titles = ['Adjacent layers only', 'Adjacent + 1-layer skips', 'All connections (adjacent + 1 & 2-layer skips)'];
            document.getElementById('legendTitle').textContent = titles[edgeSkipLayers];
            
            const edgeStr = activeLayers.length === 0 ? 'None' : activeLayers.map(l => `L${l}`).join(', ');
            const nodeStr = visibleNodeLayers.length === 0 ? 'None' : visibleNodeLayers.map(l => `L${l}`).join(', ');
            document.getElementById('legendSubtitle').textContent = `Edge sources: ${edgeStr} • Visible nodes: ${nodeStr}`;
        }

        function toggleAllNodes() {
            const allActive = nodeData.every(n => n.active);
            nodeData.forEach(n => {
                n.active = !allActive;
            });
        }

        function resetPositions() {
            nodeData.slice(0, 4).forEach((node, idx) => {
                const positions = [
                    [-3, -2.5, -3],
                    [3, -2.5, -3],
                    [3, -2.5, 3],
                    [-3, -2.5, 3]
                ];
                node.x = positions[idx][0];
                node.y = positions[idx][1];
                node.z = positions[idx][2];
                node.vx = 0;
                node.vy = 0;
                node.vz = 0;
            });
            
            nodeData.slice(4, 10).forEach((node, idx) => {
                const angle = (idx / 6) * Math.PI * 2;
                node.x = Math.cos(angle) * 3.5;
                node.y = 0.2;
                node.z = Math.sin(angle) * 3.5;
                node.vx = 0;
                node.vy = 0;
                node.vz = 0;
            });
            
            nodeData.slice(10, 14).forEach((node, idx) => {
                const angle = (idx / 4) * Math.PI * 2 + Math.PI / 4;
                node.x = Math.cos(angle) * 2;
                node.y = 2.6;
                node.z = Math.sin(angle) * 2;
                node.vx = 0;
                node.vy = 0;
                node.vz = 0;
            });
            
            nodeData[14].x = 0;
            nodeData[14].y = 5.4;
            nodeData[14].z = 0;
            nodeData[14].vx = 0;
            nodeData[14].vy = 0;
            nodeData[14].vz = 0;
        }

        function setEdgeSkip(level) {
            edgeSkipLayers = level;
            document.getElementById('skip0').className = level === 0 ? 'active' : '';
            document.getElementById('skip1').className = level === 1 ? 'active' : '';
            document.getElementById('skip2').className = level === 2 ? 'active' : '';
            createScene();
            updateLegend();
        }

        function toggleEdgeLayer(layer) {
            const idx = activeLayers.indexOf(layer);
            if (idx > -1) {
                activeLayers.splice(idx, 1);
            } else {
                activeLayers.push(layer);
                activeLayers.sort();
            }
            
            const btn = document.getElementById('edge' + layer);
            const classes = ['', 'active-blue', 'active-purple', 'active-pink'];
            btn.className = activeLayers.includes(layer) ? classes[layer] : '';
            
            createScene();
            updateLegend();
        }

        function toggleNodeLayer(layer) {
            const idx = visibleNodeLayers.indexOf(layer);
            if (idx > -1) {
                visibleNodeLayers.splice(idx, 1);
            } else {
                visibleNodeLayers.push(layer);
                visibleNodeLayers.sort();
            }
            
            const btn = document.getElementById('node' + layer);
            const classes = ['', 'active-blue', 'active-purple', 'active-pink', 'active-amber'];
            btn.className = visibleNodeLayers.includes(layer) ? classes[layer] : '';
            
            updateLegend();
        }

        window.onload = init;
    </script>
</body>
</html>
