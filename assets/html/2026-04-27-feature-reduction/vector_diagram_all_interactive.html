<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Vector Diagram - All Vectors</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        .container {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        canvas {
            border: 1px solid #444;
            cursor: pointer;
            display: block;
            background: #1e1e1e;
        }
        .instructions {
            margin-top: 15px;
            padding: 10px;
            background: #262626;
            border-radius: 4px;
            font-size: 14px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="vectorCanvas" width="600" height="600"></canvas>
        <div class="instructions">
            Click and drag near any colored circle to rotate that vector. All combination vectors will update in real-time.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('vectorCanvas');
        const ctx = canvas.getContext('2d');
        
        // Configuration
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const vectorLength = 150;
        const circleRadius = 8;
        const clickRadius = 25; // Detection radius for clicking vectors
        
        // Colors
        const color1 = '#1DA37E'; // Green
        const color2 = '#A75F9A'; // Purple
        const color3 = '#AA6600'; // Orange
        
        // Vector angles (in radians)
        let vector1Angle = 0; // Green - starts on positive x-axis
        let vector2Angle = Math.PI / 2; // Purple - starts on positive y-axis
        let vector3Angle = Math.PI * 5 / 4; // Orange - starts in lower left quadrant
        
        let isDragging = false;
        let activeVector = null; // Which vector is being dragged (1, 2, or 3)
        
        function drawGrid() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function drawShadedRegions() {
            // Helper function to draw a shaded triangular region between center and two vectors
            function drawShadedTriangle(angle1, angle2, color) {
                const end1X = centerX + vectorLength * Math.cos(angle1);
                const end1Y = centerY - vectorLength * Math.sin(angle1);
                const end2X = centerX + vectorLength * Math.cos(angle2);
                const end2Y = centerY - vectorLength * Math.sin(angle2);
                
                ctx.fillStyle = color + '33'; // Add transparency (20% opacity)
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(end1X, end1Y);
                ctx.lineTo(end2X, end2Y);
                ctx.closePath();
                ctx.fill();
            }
            
            // Calculate combination angles
            function getMidAngle(angle1, angle2) {
                let diff = angle2 - angle1;
                while (diff > Math.PI) diff -= 2 * Math.PI;
                while (diff < -Math.PI) diff += 2 * Math.PI;
                return angle1 + diff / 2;
            }
            
            const combo12 = getMidAngle(vector1Angle, vector2Angle);
            const combo13 = getMidAngle(vector1Angle, vector3Angle);
            const combo23 = getMidAngle(vector2Angle, vector3Angle);
            
            // Draw shaded regions for vector 1 (green)
            drawShadedTriangle(vector1Angle, combo12, color1);
            drawShadedTriangle(vector1Angle, combo13, color1);
            
            // Draw shaded regions for vector 2 (purple)
            drawShadedTriangle(vector2Angle, combo12, color2);
            drawShadedTriangle(vector2Angle, combo23, color2);
            
            // Draw shaded regions for vector 3 (orange)
            drawShadedTriangle(vector3Angle, combo13, color3);
            drawShadedTriangle(vector3Angle, combo23, color3);
        }
        
        function drawAxes() {
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.stroke();
            
            // Axis labels
            ctx.fillStyle = '#aaa';
            ctx.font = '14px Arial';
            ctx.fillText('x', canvas.width - 20, centerY - 10);
            ctx.fillText('y', centerX + 10, 20);
        }
        
        function drawVector(angle, color, label, includeCircle = true) {
            const endX = centerX + vectorLength * Math.cos(angle);
            const endY = centerY - vectorLength * Math.sin(angle);
            
            // Draw vector line
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Draw arrowhead
            const arrowSize = 10;
            const arrowAngle = Math.PI / 6;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - arrowSize * Math.cos(angle - arrowAngle),
                endY + arrowSize * Math.sin(angle - arrowAngle)
            );
            ctx.lineTo(
                endX - arrowSize * Math.cos(angle + arrowAngle),
                endY + arrowSize * Math.sin(angle + arrowAngle)
            );
            ctx.closePath();
            ctx.fill();
            
            // Draw circle at the end with enhanced styling
            if (includeCircle) {
                // Add subtle shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Draw outer glow
                ctx.fillStyle = color + '80'; // Semi-transparent version
                ctx.beginPath();
                ctx.arc(endX, endY, circleRadius + 3, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw main circle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(endX, endY, circleRadius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Add white border for definition
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(endX, endY, circleRadius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Add highlight for 3D effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(endX - circleRadius * 0.3, endY - circleRadius * 0.3, circleRadius * 0.4, 0, 2 * Math.PI);
                ctx.fill();
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
            
            return { endX, endY };
        }
        
        function drawCombinationVector(angle1, angle2, colors) {
            // Calculate the midpoint angle between two vectors
            // Need to handle the case where angles wrap around (e.g., 350° and 10°)
            let midAngle;
            let diff = angle2 - angle1;
            
            // Normalize the difference to be between -π and π
            while (diff > Math.PI) diff -= 2 * Math.PI;
            while (diff < -Math.PI) diff += 2 * Math.PI;
            
            // Calculate midpoint taking the shorter arc
            midAngle = angle1 + diff / 2;
            
            const endX = centerX + vectorLength * Math.cos(midAngle);
            const endY = centerY - vectorLength * Math.sin(midAngle);
            
            // Draw vector line with gradient or dashed style
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw circles at the end for both colors with enhanced styling
            colors.forEach((color, index) => {
                const offset = (index - 0.5) * circleRadius * 1.5;
                const perpX = -Math.sin(midAngle) * offset;
                const perpY = -Math.cos(midAngle) * offset;
                
                const circleX = endX + perpX;
                const circleY = endY + perpY;
                const smallRadius = circleRadius * 0.8;
                
                // Add subtle shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                
                // Draw outer glow
                ctx.fillStyle = color + '80'; // Semi-transparent version
                ctx.beginPath();
                ctx.arc(circleX, circleY, smallRadius + 2, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw main circle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(circleX, circleY, smallRadius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Add white border for definition
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(circleX, circleY, smallRadius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Add highlight for 3D effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(circleX - smallRadius * 0.3, circleY - smallRadius * 0.3, smallRadius * 0.35, 0, 2 * Math.PI);
                ctx.fill();
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            });
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGrid();
            drawAxes();
            
            // Draw shaded regions first (so they appear behind vectors)
            drawShadedRegions();
            
            // Draw all three main vectors
            drawVector(vector1Angle, color1, 'Vector 1');
            drawVector(vector2Angle, color2, 'Vector 2');
            drawVector(vector3Angle, color3, 'Vector 3');
            
            // Draw combination between vector 1 and vector 2
            drawCombinationVector(vector1Angle, vector2Angle, [color1, color2]);
            
            // Draw combination between vector 1 and vector 3
            drawCombinationVector(vector1Angle, vector3Angle, [color1, color3]);
            
            // Draw combination between vector 2 and vector 3
            drawCombinationVector(vector2Angle, vector3Angle, [color2, color3]);
        }
        
        function getMouseAngle(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            const dx = mouseX - centerX;
            const dy = centerY - mouseY; // Invert y-axis
            
            return Math.atan2(dy, dx);
        }
        
        function getVectorEndPoint(angle) {
            return {
                x: centerX + vectorLength * Math.cos(angle),
                y: centerY - vectorLength * Math.sin(angle)
            };
        }
        
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        
        function findClosestVector(mouseX, mouseY) {
            const vectors = [
                { angle: vector1Angle, id: 1 },
                { angle: vector2Angle, id: 2 },
                { angle: vector3Angle, id: 3 }
            ];
            
            let closestVector = null;
            let minDistance = clickRadius;
            
            vectors.forEach(vector => {
                const end = getVectorEndPoint(vector.angle);
                const dist = distance(mouseX, mouseY, end.x, end.y);
                
                if (dist < minDistance) {
                    minDistance = dist;
                    closestVector = vector.id;
                }
            });
            
            return closestVector;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            activeVector = findClosestVector(mouseX, mouseY);
            
            if (activeVector) {
                isDragging = true;
                const angle = getMouseAngle(e);
                
                if (activeVector === 1) vector1Angle = angle;
                else if (activeVector === 2) vector2Angle = angle;
                else if (activeVector === 3) vector3Angle = angle;
                
                draw();
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && activeVector) {
                const angle = getMouseAngle(e);
                
                if (activeVector === 1) vector1Angle = angle;
                else if (activeVector === 2) vector2Angle = angle;
                else if (activeVector === 3) vector3Angle = angle;
                
                draw();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            activeVector = null;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            activeVector = null;
        });
        
        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            
            activeVector = findClosestVector(mouseX, mouseY);
            
            if (activeVector) {
                isDragging = true;
                const angle = getMouseAngle(touch);
                
                if (activeVector === 1) vector1Angle = angle;
                else if (activeVector === 2) vector2Angle = angle;
                else if (activeVector === 3) vector3Angle = angle;
                
                draw();
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging && activeVector) {
                const touch = e.touches[0];
                const angle = getMouseAngle(touch);
                
                if (activeVector === 1) vector1Angle = angle;
                else if (activeVector === 2) vector2Angle = angle;
                else if (activeVector === 3) vector3Angle = angle;
                
                draw();
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
            activeVector = null;
        });
        
        // Initial draw
        draw();
    </script>
</body>
</html>