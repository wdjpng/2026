<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Tracing the Principles Behind Modern Diffusion Models | ICLR Blogposts 2026 </title> <meta name="author" content="ICLR Blog"> <meta name="description" content="Diffusion models can feel like a jungle of acronyms, but the core idea is simple: start from noise and gradually move a cloud of samples until it looks like real data. This post gives an intuition-first tour showing that DDPMs, score-based models, and flow matching are the same recipe with different prediction targets, all rooted in the change-of-variable rule from calculus and powered by one shared “conditional trick” that turns learning into supervised regression. Finally, we zoom out to the speed problem and show how flow map models aim to replace many tiny denoising steps with a few big, accurate jumps toward real-time generation."> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, icl# add your own keywords or leave empty"> <link rel="stylesheet" href="/2026/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/2026/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/2026/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/2026/assets/img/iclr_favicon.ico?0a8a3afdb0dbe139723b24dba3052a4f"> <link rel="stylesheet" href="/2026/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://iclr-blogposts.github.io/2026/blog/2026/tracing-principles-behind-modern-diffusion-models/"> <script src="/2026/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/2026/assets/js/distillpub/template.v2.js"></script> <script src="/2026/assets/js/distillpub/transforms.v2.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Tracing the Principles Behind Modern Diffusion Models",
            "description": "Diffusion models can feel like a jungle of acronyms, but the core idea is simple: start from noise and gradually move a cloud of samples until it looks like real data. This post gives an intuition-first tour showing that DDPMs, score-based models, and flow matching are the same recipe with different prediction targets, all rooted in the change-of-variable rule from calculus and powered by one shared “conditional trick” that turns learning into supervised regression. Finally, we zoom out to the speed problem and show how flow map models aim to replace many tiny denoising steps with a few big, accurate jumps toward real-time generation.",
            "published": "April 27, 2026",
            "authors": [
              
              {
                "author": "Anonymous",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2026/"> ICLR Blogposts 2026 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2026/">home </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/about/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/call/">call for blogposts </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/submitting/">submitting </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/reviewing/">reviewing </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2026/"><strong>2026</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2025/">2025</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2024/">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2023/">2023</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blog-track.github.io/home/" rel="external nofollow noopener" target="_blank">2022</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Tracing the Principles Behind Modern Diffusion Models</h1> <p>Diffusion models can feel like a jungle of acronyms, but the core idea is simple: start from noise and gradually move a cloud of samples until it looks like real data. This post gives an intuition-first tour showing that DDPMs, score-based models, and flow matching are the same recipe with different prediction targets, all rooted in the change-of-variable rule from calculus and powered by one shared “conditional trick” that turns learning into supervised regression. Finally, we zoom out to the speed problem and show how flow map models aim to replace many tiny denoising steps with a few big, accurate jumps toward real-time generation.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#i-a-systematic-tour-of-diffusion-models">I. A Systematic Tour of Diffusion Models</a> </div> <ul> <li> <a href="#the-generative-goal">The Generative Goal</a> </li> <li> <a href="#forward-process">Forward Process</a> </li> <li> <a href="#reverse-process">Reverse Process</a> </li> </ul> <div> <a href="#ii-change-of-variable-formulas">II. Change-of-Variable Formulas</a> </div> <ul> <li> <a href="#the-intuition">The Intuition</a> </li> <li> <a href="#the-math-we-already-know">The Math We Already Know</a> </li> <li> <a href="#from-one-big-map-to-a-time-evolution">From One Big Map to a Time-Evolution</a> </li> <li> <a href="#enter-the-noise">Enter the Noise</a> </li> </ul> <div> <a href="#iii-from-slow-samplers-to-flow-maps">III. From Slow Samplers to Flow Maps</a> </div> <ul> <li> <a href="#what-is-a-flow-map-model">What Is a Flow Map Model?</a> </li> <li> <a href="#three-flow-map-families">Three Flow Map Families</a> </li> <li> <a href="#how-the-three-flow-map-families-relate">How the Three Flow Map Families Relate</a> </li> </ul> <div> <a href="#conclusion">Conclusion</a> </div> </nav> </d-contents> <p>Modern diffusion models are often introduced through a long list of concepts and terms whose relationships are not immediately clear. Very quickly, one encounters names such as <em>DDPM, SDE, ODE, probability flow, flow matching, distillaion, consistency, flow map</em>, together with phrases like <em>forward process, reverse process, score, velocity field, sampler</em>. For a reader encountering these ideas for the first time, this can be overwhelming.</p> <p>In what follows, we slow the story down and keep a single guiding thread:</p> <blockquote> <p>All these models describe different ways to <em>move probability mass</em> from “simple noise” to “complicated data”. Under the surface, they are all based on the same principle from calculus: the <em>change-of-variable rule</em>.</p> </blockquote> <p>In the rest of this article, we build the picture step by step.</p> <p>We start with three common lenses on diffusion, <em>DDPM</em>, <em>score-based methods</em>, and <em>flow matching</em>. They share the same recipe: fix a simple <em>forward Gaussian noising process</em>, then learn to reverse it. The main difference is <em>what the network predicts</em>, such as noise, score, or velocity.</p> <p>Underneath all of them is the same math question: when we <em>move a cloud of samples</em>, how does the distribution change? The answer is the change-of-variable rule from Calculus applied to a particle cloud. In continuous time, this becomes the PDE view: pure transport gives the <em>continuity equation</em>, and transport with Gaussian jitter gives the <em>Fokker–Planck equation</em>. This matters because it is the bookkeeping that keeps the story honest: once we pre-specify the forward noising process, we have a specific path of snapshot distributions in mind, and the reverse-time generator must move probability mass in a way that stays consistent with that path. Without this structure, there is nothing tying the reverse-time generator to the intended transition from prior to data, so the learned dynamics can quietly drift away from the distribution evolution we had in mind.</p> <p>Finally, we focus on speed. Diffusion is <em>high fidelity</em> but often slow because sampling is iterative. We end with <em>flow map models</em>, which keep the same diffusion backbone but aim to learn <em>long time-jumps</em> of the probability-flow dynamics directly, replacing many tiny steps with a few big, accurate jumps.</p> <h1 id="i-a-systematic-tour-of-diffusion-models">I. A Systematic Tour of Diffusion Models</h1> <h2 id="the-generative-goal">The Generative Goal</h2> <p>We first discuss the goal, before introducing any technical machinery.</p> <p>On the simple side, we can easily generate randomness. For example, we can draw a vector of independent Gaussian variables, which looks like pure “static”. On the complex side, we have realistic data: natural images, short audio clips, 3D shapes, and so on. These objects are high-dimensional and exhibit rich structure. A <em>deep generative model</em> is a procedure that maps from the simple side to the complex side. It turns noise into data.</p> <p>At an abstract level, we can depict this as</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/dgm-learning.svg" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/dgm-learning.svg" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Classical models such as GANs and VAEs attempt to learn this arrow in one or a few large steps: a single neural network takes a noise vector and outputs an image.</p> <p><strong>Diffusion-style models</strong> follow a different philosophy. Instead of jumping directly from noise to data, they move in many <em>small increments</em>. More precisely, the construction consists of two coupled procedures:</p> <ul> <li>In the <strong>forward process</strong>, we start from real data and gradually add small amounts of simple random noise at many tiny steps. As this corruption progresses, fine details disappear first, then larger structures become indistinct, and eventually every sample looks like featureless noise. By the end, all examples, regardless of which original image or sound they came from, are brought into a <em>common noisy space</em> that is very close to a standard Gaussian distribution and easy to sample from. Although we typically do not run this forward process at test time, it is essential during training because it provides a precise, controlled way to relate clean data to their noisy versions.</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/vdm-forward.svg" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/vdm-forward.svg" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>In the <strong>reverse process</strong>, the model learns to undo this artificial corruption step by step. Starting from pure noise, it applies a sequence of learned denoising updates that gradually reintroduce structure: coarse shapes first, then finer details. After enough steps, the final outputs resemble realistic data again. This reverse procedure is what we actually use at sampling time to turn noise into data.</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/vdm-backward.svg" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/vdm-backward.svg" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>In both directions, there is a common underlying object: a <em>probability denity</em> that evolves over time. At time \(t = 0\), we may have a density that is shaped like the data distribution. As \(t\) increases, the forward process transports and blurs this density until it approaches a simple reference distribution, often called the <em>prior</em>. In practice, this prior is typically chosen to be a standard Gaussian, because we know how to sample from it efficiently and its properties admit closed-form expressions.</p> <p>At this point, the big picture is in place: we have a simple way to <em>corrupt</em> data into noise, and we hope to learn a reverse procedure that <em>undoes</em> that corruption.</p> <p>So the next step is to pin down a <em>fully explicit</em> forward rule that we can define ourselves: given a clean sample \(\mathbf{x}_0\), what is the distribution of its noisy version \(\mathbf{x}_t\) at each time \(t\)? Once this rule is fixed, we can talk precisely about different reverse-time modeling choices built on top of the <em>same</em> forward construction.</p> <h2 id="forward-process">Forward Process</h2> <p>It helps to first make the <em>forward noising rule</em> completely concrete. Modern common diffusion models (such as DDPM, Score SDE, Flow Matching) that we will revisit in this post all start from this same basic construction.</p> <p>Let $\mathbf{x}_0 \in \mathbb{R}^D$ be a clean data sample (an image, an audio clip, etc.) sampled from a given data distributio \(p_{\text{data}}\). The forward process gradually corrupts $\mathbf{x}_0$ into a noisy version $\mathbf{x}_t$. A standard and very convenient choice is:</p> \[p(\mathbf{x}_t \mid \mathbf{x}_0) = \mathcal{N}\bigl(\mathbf{x}_t;\,\alpha_t\,\mathbf{x}_0,\;\sigma_t^2\,\mathbf{I}\bigr),\] <p>where $\alpha_t$ and $\sigma_t$ are scalar functions of the “time” $t$, and $\mathbf{I}$ is the identity matrix. Equivalently, we can sample</p> \[\boldsymbol{\epsilon} \sim \mathcal{N}(\mathbf{0}, \mathbf{I}), \qquad \mathbf{x}_t = \alpha_t \mathbf{x}_0 + \sigma_t \boldsymbol{\epsilon}.\] <p>We can think of $\alpha_t$ as the amount of original signal that remains at time $t$, and $\sigma_t$ as the amount of noise that has been mixed in:</p> <ul> <li>for small $t$, $\alpha_t \approx 1$ and $\sigma_t \approx 0$, so $\mathbf{x}_t$ is close to $\mathbf{x}_0$;</li> <li>for large $t$, $\alpha_t \approx 0$ and $\sigma_t$ is large, so $\mathbf{x}_t$ is almost pure noise.</li> </ul> <p>With this forward perturbation, we can view the data distribution as being “blurred” over time. The resulting time-dependent marginal density is</p> \[p_t(\mathbf{x}):= \int p(\mathbf{x}_t \mid \mathbf{x}_0) p_{\text{data}}(\mathbf{x}_0) \mathrm{d} \mathbf{x}_0.\] <h2 id="reverse-process">Reverse Process</h2> <p>Once the forward noising process is fixed, most diffusion “flavors” differ in just two choices:</p> <ol> <li>What the network predicts from \((\mathbf{x}_t, t)\), and</li> <li>How we use that prediction at sampling time to go from noise back to data.</li> </ol> <p>Below we outline three widely used viewpoints that all tell the same story:</p> <ul> <li> <strong>Variational Perspective:</strong> predict the <em>noise that was added</em> (or, equivalently, a cleaned-up version of the sample), then use it to take one denoising step. A representative model in this family is <em>Denoising Diffusion Probabilistic Models (DDPM)</em>.</li> <li> <strong>Score-based Perspective:</strong> predict a score function, i.e., the <em>direction pointing toward more likely images</em> at noise level $t$, and then follow it to move from noise back to data. The representative one <em>Score SDE</em>.</li> <li> <strong>Flow-based Perspective:</strong> predict a <em>velocity (a “push”)</em> telling how to move the sample at time \(t\), then integrate these pushes to transport noise into data. The representative example is <em>Flow Matching</em>.</li> </ul> <h3 id="ddpm-predicting-the-reverse-step-via-noise-or-mean">DDPM: Predicting the Reverse Step via Noise or Mean</h3> <p>Denoising Diffusion Probabilistic Models (DDPM) <d-cite key="sohl2015deep,ho2020denoising"></d-cite> are one of the earliest modern diffusion approaches. The main idea is simple: with the fix forward noising process that gradually destroys data, it <em>trains a model to run this process in reverse</em>. DDPM formalizes this as a variational objective, so that learning to denoise step by step also corresponds to maximizing a likelihood-style training goal.</p> <p>In DDPM, we work with a <em>discrete</em> set of noise levels, for example integer times $t = 0, 1, \dots, T$. The <em>forward</em> process gradually increases the noise level so that $\mathbf{x}_T$ is (almost) standard Gaussian.</p> <p>Conceptually, what we would like to have is the <em>oracle reverse transition kernel</em> that undoes this forward corruption:</p> \[p(\mathbf{x}_{t-1} \mid \mathbf{x}_t), \quad t = T, T-1, \dots, 1,\] <p>so that if we start from $\mathbf{x}_T \sim \mathcal{N}(\mathbf{0}, \mathbf{I})$ and keep sampling backwards</p> \[\mathbf{x}_T \to \mathbf{x}_{T-1} \to \cdots \to \mathbf{x}_0,\] <p>the final $\mathbf{x}_0$ looks like a real data sample.</p> <p>To make the generative process work, we would like to learn the true reverse kernel \(p(\mathbf{x}_{t-1}\mid \mathbf{x}_t)\), by fitting a parametric model \(p_\theta(\mathbf{x}_{t-1}\mid \mathbf{x}_t)\) and minimizing the expected KL</p> \[\mathbb{E}_{p_t(\mathbf{x}_t)} \big[ D_{\mathrm{KL}}\big(p(\mathbf{x}_{t-1}\mid \mathbf{x}_t)\,\|\,p_\theta(\mathbf{x}_{t-1}\mid \mathbf{x}_t)\big) \big].\] <p>At first sight, this looks hopeless: the marginal reverse kernel</p> \[p(\mathbf{x}_{t-1}\mid \mathbf{x}_t) = \int p(\mathbf{x}_{t-1}\mid \mathbf{x}_t,\mathbf{x}_0)\,p_{\text{data}}(\mathbf{x}_0)\mathrm{d}\mathbf{x}_0\] <p>is a complicated <em>mixture of Gaussians</em> over all possible clean images \(\mathbf{x}_0\), and we never see it in closed form.</p> <p>The key move, which we call the <em>conditional trick</em>, is to <em>condition on the clean data</em> \(\mathbf{x}_0\) to obtain a tractable regression target. Because the forward process is Markov and Gaussian, the conditional kernel \(p(\mathbf{x}_{t-1}\mid \mathbf{x}_t, \mathbf{x}_0)\) is itself a single Gaussian with a closed-form mean and variance.</p> <p>A neat calculation shows that the original “impossible” objective can be rewritten as</p> <div style="background:rgba(255,165,0,0.12); padding:12px; border-radius:10px; max-width:100%; overflow-x:auto; overflow-y:hidden;"> $$ \mathbb{E}_{p_t(\mathbf{x}_t)}\!\big[ D_{\mathrm{KL}}(p(\mathbf{x}_{t-1}\mid \mathbf{x}_t)\,\|\,p_\theta(\mathbf{x}_{t-1}\mid \mathbf{x}_t)) \big] = \mathbb{E}_{p_{\text{data}}(\mathbf{x}_0)}\mathbb{E}_{p(\mathbf{x}_t\mid \mathbf{x}_0)} \big[ D_{\mathrm{KL}}(p(\mathbf{x}_{t-1}\mid \mathbf{x}_t,\mathbf{x}_0)\,\|\,p_\theta(\mathbf{x}_{t-1}\mid \mathbf{x}_t)) \big] + C, $$ </div> <p>where \(C\) is a constant independent of \(\theta\).</p> <p>In words: instead of trying to match the unknown mixture \(p(\mathbf{x}_{t-1}\mid \mathbf{x}_t)\) directly, we match the <em>Gaussian conditional</em> \(p(\mathbf{x}_{t-1}\mid \mathbf{x}_t,\mathbf{x}_0)\) for random data points \(\mathbf{x}_0\). This conditional objective is mathematically equivalent to the original KL up to a constant, but now the target is <em>fully tractable</em>.</p> <p>This conditional trick will reappear in score-based SDEs and flow matching: in all three views, conditioning on \(\mathbf{x}_0\) turns an intractable object (reverse kernel, score, or velocity) into a simple regression target we can actually learn.</p> <p>Because the forward noising rule is <em>linear and Gaussian</em>, the one-step reverse transition has a convenient form: it is also Gaussian. So DDPM models the reverse kernel as</p> \[p_\theta(\mathbf{x}_{t-1}\mid \mathbf{x}_t) := \mathcal{N}\!\big(\boldsymbol{\mu}_\theta(\mathbf{x}_t,t),\,\tilde{\sigma}_t^2\mathbf{I}\big).\] <p>Here \(\tilde{\sigma}_t^2\) is a <em>known</em> (pre-chosen) variance schedule, so the only learnable part is the mean \(\boldsymbol{\mu}_\theta(\mathbf{x}_t,t)\).</p> <p>A key practical simplification is that we usually <em>do not</em> ask the network to output this mean directly. Instead, we exploit the closed-form forward relation</p> \[\mathbf{x}_t=\alpha_t\mathbf{x}_0+\sigma_t\boldsymbol{\epsilon}, \qquad \boldsymbol{\epsilon}\sim\mathcal{N}(\mathbf{0},\mathbf{I}),\] <p>which implies that the reverse mean can be written as an <em>explicit formula</em> once we know either the clean image \(\mathbf{x}_0\) or the noise \(\boldsymbol{\epsilon}\). So we train the network to predict one of these simpler quantities, and then <em>plug it into</em> the analytic formula for \(\boldsymbol{\mu}_\theta(\mathbf{x}_t,t)\).</p> <p>In the original DDPM formulation, the standard choice is to predict the noise. Concretely, we train \(\boldsymbol{\epsilon}_\theta(\mathbf{x}_t,t)\) with the regression objective</p> \[\mathcal{L}_{\text{variational}}(\theta) = \mathbb{E}_{t,\,\mathbf{x}_0,\,\boldsymbol{\epsilon}} \Big[ \lambda(t)\, \big\| \boldsymbol{\epsilon}_\theta(\mathbf{x}_t,t)-\boldsymbol{\epsilon} \big\|_2^2 \Big],\] <p>where \(\lambda(t)\) is a time-dependent weight.</p> <p>Intuitively: the network sees a noisy sample \(\mathbf{x}_t\) and its noise level \(t\), and learns to answer “<em>What noise was added to create this sample?</em>”</p> <p>At sampling time, we start from \(\mathbf{x}_T\sim\mathcal{N}(\mathbf{0},\mathbf{I})\). At each step, we use \(\boldsymbol{\epsilon}_\theta(\mathbf{x}_t,t)\) to compute the Gaussian mean \(\boldsymbol{\mu}_\theta(\mathbf{x}_t,t)\) (via the closed-form reverse formula), sample \(\mathbf{x}_{t-1}\), and repeat until we reach a clean sample \(\mathbf{x}_0\).</p> <h3 id="score-based-methods-predict-the-score">Score-Based Methods: Predict the Score</h3> <p>Score-based diffusion models <d-cite key="song2020score"></d-cite> keep the same forward corruption rule for \(\mathbf{x}_t\), but they train the network to predict a different object: the <em>score</em> at each noise level \(t\),</p> \[\nabla_{\mathbf{x}}\log p_t(\mathbf{x}),\] <p>where \(p_t\) is the (unknown) marginal density of noisy samples at time \(t\). Intuitively, the score is a local arrow that points toward <em>more likely</em> samples under \(p_t\).</p> <p>Of course, we cannot compute \(\nabla_{\mathbf{x}}\log p_t(\mathbf{x})\) directly because \(p_t\) is defined by integrating over the data. The <em>conditional trick</em> is to instead use the Gaussian conditional \(p(\mathbf{x}_t\mid \mathbf{x}_0)\), whose score is available in closed form:</p> \[\nabla_{\mathbf{x}_t}\log p(\mathbf{x}_t\mid \mathbf{x}_0) = -\frac{1}{\sigma_t^2}\bigl(\mathbf{x}_t-\alpha_t\mathbf{x}_0\bigr).\] <p>Since \(\mathbf{x}_t=\alpha_t\mathbf{x}_0+\sigma_t\boldsymbol{\epsilon}\), this target is equivalently \(-\frac{1}{\sigma_t}\boldsymbol{\epsilon},\) which makes the supervision feel very concrete: “given a noisy sample, point in the direction that removes the injected noise.”</p> <p>Training then becomes a plain regression problem. We sample \(\mathbf{x}_0\), choose \(t\), draw \(\boldsymbol{\epsilon}\sim\mathcal{N}(\mathbf{0},\mathbf{I})\), form \(\mathbf{x}_t\), and minimize the <em>denoising score matching</em> loss</p> \[\mathcal{L}_{\text{score}}(\theta) = \mathbb{E}_{t,\,\mathbf{x}_0,\,\boldsymbol{\epsilon}} \Big[ \lambda(t)\, \big\| \mathbf{s}_\theta(\mathbf{x}_t,t) +\frac{1}{\sigma_t^2}\bigl(\mathbf{x}_t-\alpha_t\mathbf{x}_0\bigr) \big\|_2^2 \Big].\] <p>More precisely, <em>denoising score matching</em> gives the same kind of “conditional trick” we saw in DDPM: the intractable regression target \(\nabla_{\mathbf{x}_t}\log p_t(\mathbf{x}_t)\) can be replaced by the <em>tractable</em> conditional target \(\nabla_{\mathbf{x}_t}\log p_t(\mathbf{x}_t\mid \mathbf{x}_0)\), and the two objectives differ only by a constant (so they induce the same gradient updates and the same optimum). Formally, for a constant \(C\) that does <em>not</em> depend on \(\theta\),</p> <div style="background:rgba(255,165,0,0.12); padding:12px; border-radius:10px; max-width:100%; overflow-x:auto; overflow-y:hidden;"> $$ \mathbb{E}_{t}\,\mathbb{E}_{\mathbf{x}_t\sim p_t} \Big[ \lambda(t)\, \big\| \mathbf{s}_\theta(\mathbf{x}_t,t) - \nabla_{\mathbf{x}_t}\log p_t(\mathbf{x}_t) \big\|_2^2 \Big] = \mathbb{E}_{t}\,\mathbb{E}_{\mathbf{x}_0\sim p_{\text{data}}}\,\mathbb{E}_{\mathbf{x}_t\sim p(\cdot\mid \mathbf{x}_0)} \Big[ \lambda(t)\, \big\| \mathbf{s}_\theta(\mathbf{x}_t,t) -\nabla_{\mathbf{x}_t}\log p_t(\mathbf{x}_t\mid \mathbf{x}_0) \big\|_2^2 \Big] + C. $$ </div> <p>At test time, the learned score field \(\mathbf{s}_\theta\) is turned into an actual sampler by following a continuous-time dynamics. A particularly clean option is the <em>probability-flow ODE (PF-ODE)</em>: a <em>deterministic</em> trajectory whose intermediate distributions match those of the stochastic diffusion process.</p> <p>The PF-ODE takes the form</p> \[\frac{\mathrm{d}\mathbf{x}(t)}{\mathrm{d}t} = f(t)\mathbf{x}(t) -\frac{1}{2}g^2(t)\mathbf{s}_\theta(\mathbf{x}(t),t).\] <p>Here, the coefficients \(f(t)\) and \(g(t)\) are tied to the forward perturbation \(\mathbf{x}_t=\alpha_t\mathbf{x}_0+\sigma_t\boldsymbol{\epsilon}\) through</p> \[f(t)=\frac{\mathrm{d}}{\mathrm{d}t}\log\alpha_t=\frac{\dot{\alpha}_t}{\alpha_t}, \quad\text{and}\quad g^2(t)=\frac{\mathrm{d}}{\mathrm{d}t}\sigma_t^2-2f(t)\sigma_t^2.\] <p>The key point is that the PF-ODE is constructed so that, for every time \(t\), the random variable \(\mathbf{x}(t)\) has distribution exactly \(p_t\). So even though each trajectory is deterministic, the sampler still matches the same “distribution snapshot” at each noise level.</p> <p>Starting from a seed drawn from the prior, \(\mathbf{x}_T\sim p_{\text{prior}}\), we numerically integrate the PF-ODE backward from \(t=T\) to \(t=0\). The endpoint \(\mathbf{x}_0\) is then a data-like sample.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/continuous_ode.svg" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/continuous_ode.svg" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>The score SDE framework can be viewed as a <em>continuous-time</em> extension of DDPM. It reframes diffusion generation as solving a time-dependent differential equation, which connects generative modeling to classical tools from differential equations. We will illustrate this with concrete examples when we introduce the Flow Matching framework below, which keeps the notation simple.</p> <p>This viewpoint also makes one practical point transparent: <em>standard diffusion sampling is inherently iterative, and can therefore be slow</em>. The sample is refined through many small updates, and high quality often requires many such steps.</p> <h3 id="flow-matching-predict-the-velocity">Flow Matching: Predict the Velocity</h3> <p>In score-based diffusion, we first learn a <em>score</em> \(\mathbf{s}_\theta(\mathbf{x},t)\) (a “which way is more likely” direction), and then convert it into a sampler by integrating the PF-ODE. Flow matching <d-cite key="lipman2022flow"></d-cite> shifts the focus: instead of learning the score, it trains the network to output the <em>velocity field</em> directly, the ODE rule that moves a sample at time \(t\).</p> <p>We start from the same linear-Gaussian coupling between clean data and noisy data: \(\mathbf{x}_t=\alpha_t\mathbf{x}_0+\sigma_t\boldsymbol{\epsilon}\), with \(\boldsymbol{\epsilon}\sim\mathcal{N}(\mathbf{0},\mathbf{I})\). If we imagine following this path as \(t\) changes, the instantaneous motion is just its time derivative:</p> \[\mathbf{v}^{\text{cond}}(\mathbf{x}_t,t) := \dot{\mathbf{x}}_t = \dot{\alpha}_t\,\mathbf{x}_0+\dot{\sigma}_t\,\boldsymbol{\epsilon}.\] <p>This is the familiar <em>conditional trick</em>: although we do not know the “true” marginal velocity associated with \(p_t\), conditioning on \(\mathbf{x}_0\) gives a closed-form regression target.</p> <p>Training is therefore a simple regression problem. We sample \(\mathbf{x}_0,t,\boldsymbol{\epsilon}\), form \(\mathbf{x}_t\), and fit \(\mathbf{v}_\theta(\mathbf{x}_t,t)\) to match \(\dot{\alpha}_t\mathbf{x}_0+\dot{\sigma}_t\boldsymbol{\epsilon}\):</p> \[\mathcal{L}_{\text{FM}}(\theta) = \mathbb{E}_{t,\,\mathbf{x}_0,\,\boldsymbol{\epsilon}} \Big[ \lambda(t)\, \big\| \mathbf{v}_\theta(\mathbf{x}_t,t) - (\dot{\alpha}_t\,\mathbf{x}_0+\dot{\sigma}_t\,\boldsymbol{\epsilon}) \big\|_2^2 \Big].\] <p>The only subtlety is <em>what the “right” target is</em> if our network only gets \(\mathbf{x}_t\). At time \(t\), many different clean images \(\mathbf{x}_0\) can lead to the same noisy point \(\mathbf{x}_t\), so \(\mathbf{v}^{\text{cond}}(\mathbf{x}_t,t)\) is not a single-valued function of \(\mathbf{x}_t\) alone. In squared error, the <em>best possible</em> predictor given only \(\mathbf{x}_t\) is the conditional mean of the target, under the chosen marginal path \(p_t\):</p> \[\mathbf{v}(\mathbf{x}, t) := \mathbb{E}\!\left[\mathbf{v}^{\text{cond}}(\mathbf{x}_t, t)\,\middle|\,\mathbf{x}_t=\mathbf{x}\right], \qquad \mathbf{x}_t\sim p_t.\] <p>Now the key equivalence mirrors denoising score matching. A standard squared-loss decomposition implies that, for a constant \(C\) independent of \(\theta\),</p> <div style="background:rgba(255,165,0,0.12); padding:12px; border-radius:10px; max-width:100%; overflow-x:auto; overflow-y:hidden;"> $$ \mathbb{E}_{t}\,\mathbb{E}_{\mathbf{x}_t\sim p_t} \Big[ \lambda(t)\, \big\| \mathbf{v}_\theta(\mathbf{x}_t,t)-\mathbf{v}(\mathbf{x}, t) \big\|_2^2 \Big] = \mathbb{E}_{t,\,\mathbf{x}_0,\,\boldsymbol{\epsilon}} \Big[ \lambda(t)\, \big\| \mathbf{v}_\theta(\mathbf{x}_t,t)-\mathbf{v}^{\text{cond}}(\mathbf{x}_t,t) \big\|_2^2 \Big] + C. $$ </div> <p>Namely, we rewrite the objective so we can swap an <em>unknown marginal</em> target for a <em>tractable conditional</em> one. The two losses differ only by a constant (independent of \(\theta\)), so they induce the same gradient updates and share the same optimum.</p> <p>At test time, we sample \(\mathbf{x}_T\sim\mathcal{N}(\mathbf{0},\mathbf{I})\) and integrate the learned ODE</p> \[\frac{\mathrm{d}\mathbf{x}(t)}{\mathrm{d}t}=\mathbf{v}_\theta(\mathbf{x}(t),t), \qquad t:T\to 0,\] <p>to obtain a data-like \(\mathbf{x}_0\). To actually run this on a computer, we discretize time into a grid and step <em>backward</em> from \(t\) to \(t-\Delta t\) along a chosen schedule. Each step replaces the continuous ODE with a small update rule, giving a practical approximation to the trajectory. Below are two standard concrete examples.</p> <h4 id="euler--ddim-style-step">Euler = <em>DDIM-style</em> Step</h4> <p>The simplest choice is to use the velocity at the current point:</p> \[\mathbf{x}_{t-\Delta t} = \mathbf{x}_t -\Delta t\,\mathbf{v}_\theta(\mathbf{x}_t,t).\] <p>This is the basic <em>first-order</em> Euler discretization of an ODE. With the learned diffusion-model velocity plugged in, this update recovers the familiar <em>DDIM-style deterministic sampler</em> <d-cite key="song2020denoising"></d-cite>: one model call per step, fast, but limited by first-order numerical accuracy.</p> <h4 id="heun--2nd-order-dpm-solver-style-step">Heun = <em>2nd-order DPM-Solver-style</em> Step</h4> <p>A small upgrade is to take one “draft” step, then correct it using the velocity at the endpoint.</p> <p>Predict (Euler):</p> \[\tilde{\mathbf{x}}_{t-\Delta t} = \mathbf{x}_t-\Delta t\,\mathbf{v}_\theta(\mathbf{x}_t,t).\] <p>Correct (average the two velocities):</p> \[\mathbf{x}_{t-\Delta t} = \mathbf{x}_t -\frac{\Delta t}{2}\Big( \mathbf{v}_\theta(\mathbf{x}_t,t) + \mathbf{v}_\theta(\tilde{\mathbf{x}}_{t-\Delta t},\,t-\Delta t) \Big).\] <p>This is a <em>second-order</em> method. With the diffusion-model velocity plugged in, it becomes the same predictor–corrector pattern used by <em>second-order DPM-Solver</em> variants <d-cite key="lu2022dpm"></d-cite>: two model calls per step, but typically much better accuracy at the same step budget.</p> <p>In both cases, repeating the update from \(t=T\) down to \(t=0\) yields a data-like sample \(\mathbf{x}_0\).</p> <h3 id="three-lenses-on-the-same-diffusion-path">Three Lenses on the Same Diffusion Path</h3> <p>With the same fixed forward Gaussian rule \(\mathbf{x}_t = \alpha_t \mathbf{x}_0 + \sigma_t \boldsymbol{\epsilon},\) all these methods start from the same convenience: we can generate a noisy sample \(\mathbf{x}_t\) from a clean sample \(\mathbf{x}_0\) in a fully analytic way. What changes is <em>which learnable target we use to describe (and later reverse) the evolution of the noisy marginals</em> \(p_t\):</p> <ul> <li> <em>DDPM:</em> predict the <em>noise</em> that was added (equivalently, a denoising direction / mean for one reverse step).</li> <li> <em>Score SDE:</em> predict the <em>score</em>, a direction that points toward more likely samples under \(p_t\).</li> <li> <em>Flow matching:</em> predict a <em>velocity</em>, the instantaneous “push” that transports samples along the path.</li> </ul> <p>Despite these different targets, the training recipe follows the same principle: we avoid regressing on an intractable marginal object directly. Instead, we use the known conditional \(p(\mathbf{x}_t\mid \mathbf{x}_0)\) to build a <em>closed-form conditional target</em> (noise / conditional score / conditional velocity). This is the same <em>conditional trick</em>, just shown in different forms.</p> <p>Indeed, these targets (\(\mathbf{x}\)- / \(\boldsymbol{\epsilon}\)- / score- / velocity-prediction) are not isolated choices. They are different parameterizations of the same underlying Gaussian path. For instance, the forward rule \(\mathbf{x}_t=\alpha_t\mathbf{x}_0+\sigma_t\boldsymbol{\epsilon}\) links \(\mathbf{x}_0\) and \(\boldsymbol{\epsilon}\) analytically, so knowing one lets you recover the others. As a result, the same reverse-step mean can be written using any of these parameterizations.</p> <p>Likewise, under the same marginal path \(p_t\), the “oracle” velocity that transports \(p_t\) is tied to the score via the PF-ODE identity</p> \[\mathbf{v}(\mathbf{x},t)=f(t)\mathbf{x}-\frac{1}{2}g^2(t)\mathbf{s}(\mathbf{x},t).\] <p>So, while different papers choose different training targets, they are largely <em>inter-convertible descriptions</em> of the same density evolution.</p> <p>Next, we connect this back to the calculus view: how a distribution \(p_t\) changes when we <em>move points</em> (ODE) or <em>add randomness</em> (diffusion).</p> <hr> <h1 id="ii-change-of-variable-formulas">II. Change-of-Variable Formulas</h1> <p>All the forward and reverse procedures above can be viewed through the same geometric lens: we draw many points from some distribution (data, or the prior) and then <em>move those points together</em> according to a rule. If we imagine these points as a <em>cloud</em> in space, moving every point deforms the cloud: some regions get more crowded, others become more sparse.</p> <p>This immediately raises a recurring question:</p> <blockquote> <p>In diffusion models, what happens to the underlying <em>probability density</em> when we move (and sometimes randomly perturb) all points, from the data distribution toward the prior, or back again?</p> </blockquote> <p>The first step toward a precise answer is a familiar tool from calculus: the <em>change-of-variable formula</em>.</p> <h2 id="the-intuition-a-particle-cloud">The Intuition: A Particle Cloud</h2> <p>Imagine every possible image or audio clip is a point \(\mathbf{x}\in\mathbb{R}^D\). Place a tiny particle at each data sample. Where particles cluster, the density is high; where they rarely appear, the density is low.</p> <p>Now imagine applying a transformation to every particle. The key invariant is <em>mass conservation</em>: particles move around, but they are not created or destroyed, so <em>total probability stays 1</em>. Density changes only because space is stretched or squeezed.</p> <p>Everything below is just different ways to write this idea cleanly.</p> <h2 id="the-math-we-already-know">The Math We Already Know</h2> <p>The good news is that diffusion models do not require exotic math. They mostly reuse one idea from calculus: if we <em>move points</em>, we automatically change how density concentrates. Let us start with the simplest case.</p> <h3 id="calculus-101-one-dimension">Calculus 101 (One Dimension)</h3> <p>Let \(x_0\in\mathbb{R}\) be a random variable with density \(p_0(x_0)\). Apply a smooth invertible map \(\Psi:\mathbb{R}\to\mathbb{R}\) and define \(x_1=\Psi(x_0).\) Then the density after the map is</p> \[p_1(x_1) = p_0\bigl(\Psi^{-1}(x_1)\bigr)\, \left|\frac{\mathrm{d}\Psi^{-1}}{\mathrm{d} x_1}\right|.\] <p>Intuitively, \(\Psi\) can <em>squeeze</em> or <em>stretch</em> the line. If it squeezes many \(x_0\) values into a small interval of \(x_1\), the density must go up there. If it stretches space out, density must go down. The factor \(\left|\frac{\mathrm{d}\Psi^{-1}}{\mathrm{d} x_1}\right|\) is exactly this local stretching ratio.</p> <h3 id="higher-dimensions-and-why-the-continuity-equation-is-the-same-idea">Higher Dimensions (and Why the Continuity Equation Is the Same Idea)</h3> <p>In \(\mathbb{R}^D\), the change-of-variables rule looks scarier only because of the <em>determinant</em>. Let \(\Psi:\mathbb{R}^D\to\mathbb{R}^D\) be a smooth bijection and set \(\mathbf{x}_1=\Psi(\mathbf{x}_0)\). If \(p_0\) is the density before the map and \(p_1\) after, then</p> \[p_1(\mathbf{x}_1) = p_0\bigl(\Psi^{-1}(\mathbf{x}_1)\bigr)\, \left|\det\frac{\partial \Psi^{-1}}{\partial \mathbf{x}_1}\right|.\] <p>The determinant is just a <em>local volume scale</em>: if a tiny ball of points gets stretched to have 2× the volume, then the density must drop by 2× so that <em>mass stays the same</em>.</p> <p>The takeaway we will keep using is:</p> <blockquote> <p>If we move points by an invertible map, density changes according to how much the map locally stretches or compresses space.</p> </blockquote> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/change-of-variable-480.webp 480w,/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/change-of-variable-800.webp 800w,/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/change-of-variable-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/change-of-variable.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="from-one-big-map-to-a-time-evolution">From One Big Map to a Time-Evolution</h2> <p>The change-of-variable formula tells us how <em>one</em> invertible map \(\Psi\) reshapes a density by locally stretches or compresses volume.</p> <p>To get to diffusion-style dynamics, we simply stop doing <em>one</em> big warp and instead apply <em>many tiny warps</em> in sequence. Think of a long chain of bijections:</p> \[\mathbf{x}_0 \xrightarrow{\ \Psi_1\ } \mathbf{x}_{\Delta t} \xrightarrow{\ \Psi_2\ } \mathbf{x}_{2\Delta t} \ \cdots\ \xrightarrow{\ \Psi_L\ } \mathbf{x}_{T}, \qquad \Delta t = T/L.\] <p>Each step conserves probability mass and therefore obeys the same change-of-variable rule. In log form, the Jacobian determinants just <em>add up</em>:</p> \[\log p_T(\mathbf{x}_T) = \log p_0(\mathbf{x}_0) - \sum_{k=1}^L \log\left|\det\frac{\partial \Psi_k}{\partial \mathbf{x}}\right|.\] <p>This is exactly the normalizing-flow picture, only used in <em>tiny increments</em>.</p> <p>Now make those increments concrete with a nice set of illustration. A natural “tiny warp” is to move each point a small distance along a velocity field,</p> \[\mathbf{x}_{t+\Delta t}=\mathbf{x}_t+\Delta t\,\mathbf{v}_t(\mathbf{x}_t),\] <p>or we write it as:</p> \[\Psi_{\Delta t}(\mathbf{x}):=\mathbf{x}+\Delta t\,\mathbf{v}_t(\mathbf{x}).\] <p>To understand how the density changes, keep one picture in mind: \(p_{t+\Delta t}(\mathbf{x})\) measures how much probability mass ends up near \(\mathbf{x}\) after the step.</p> <p>Change-of-variables says this comes from two first-order effects happening at once. First, the mass near \(\mathbf{x}\) must have arrived from a nearby point at time \(t\), namely the point that maps into \(\mathbf{x}\) under one step. Since the step is tiny, this “backtracked” location is simply</p> \[\Psi_{\Delta t}^{-1}(\mathbf{x}) = \mathbf{x}-\Delta t\,\mathbf{v}_t(\mathbf{x})+o(\Delta t),\] <p>so the old density is sampled slightly upstream:</p> \[p_t\!\left(\Psi_{\Delta t}^{-1}(\mathbf{x})\right) = p_t(\mathbf{x}) -\Delta t\,\mathbf{v}_t(\mathbf{x})\cdot\nabla_{\mathbf{x}}p_t(\mathbf{x}) +o(\Delta t).\] <p>Second, even if the same particles arrive, their local spacing can expand or compress, which rescales density by a Jacobian factor. Because \(\Psi_{\Delta t}\) is close to identity,</p> \[\frac{\partial \Psi_{\Delta t}}{\partial \mathbf{x}} = \mathbf{I}+\Delta t\,\nabla_{\mathbf{x}}\mathbf{v}_t(\mathbf{x}) \quad\Longrightarrow\quad \left|\det\frac{\partial \Psi_{\Delta t}^{-1}}{\partial \mathbf{x}}\right| = 1-\Delta t\,\nabla_{\mathbf{x}}\cdot\mathbf{v}_t(\mathbf{x})+o(\Delta t).\] <p>Putting these two pieces into one change-of-variable step,</p> \[p_{t+\Delta t}(\mathbf{x}) = p_t\!\left(\Psi_{\Delta t}^{-1}(\mathbf{x})\right)\, \left|\det\frac{\partial \Psi_{\Delta t}^{-1}}{\partial \mathbf{x}}\right|,\] <p>and keeping only first-order terms gives the clean update</p> \[p_{t+\Delta t}(\mathbf{x}) = p_t(\mathbf{x}) -\Delta t\,\nabla_{\mathbf{x}}\cdot\bigl(p_t(\mathbf{x})\,\mathbf{v}_t(\mathbf{x})\bigr) +o(\Delta t).\] <p>Now the limit \(\Delta t\to 0\) is just the definition of a time derivative, yielding the <em>continuity equation</em></p> <div style="background:rgba(255,165,0,0.12); padding:12px; border-radius:10px; max-width:100%; overflow-x:auto; overflow-y:hidden;"> $$ \frac{\partial p_t(\mathbf{x})}{\partial t} = -\nabla_{\mathbf{x}}\cdot\bigl(p_t(\mathbf{x})\,\mathbf{v}_t(\mathbf{x})\bigr). $$ </div> <p>So nothing mysterious happened. It is the same change-of-variable idea, applied to many tiny bijections and then viewed in the continuous-time limit.</p> <p>Physically, the continuity equation says that density changes only because probability mass <em>flows</em> across space. The backtracking part answers which mass reaches a location \(\mathbf{x}\) after a small step, while the Jacobian part tells you whether that arriving mass gets diluted (local expansion) or concentrated (local compression). In the limit, these two effects combine into one net-outflow law as the continuity equation.</p> <p>It is often helpful to name the quantity inside the divergence. The vector</p> \[\mathbf{J}_{\text{adv}}(\mathbf{x},t) := p_t(\mathbf{x})\,\mathbf{v}_t(\mathbf{x})\] <p>is called the <em>advective flux</em>. Intuitively, it is “<em>density × speed</em>”: how much probability is being carried past \(\mathbf{x}\) per unit time. With this notation, the continuity equation is just a local balance law:</p> <blockquote> <p>Density at \(\mathbf{x}\) goes <em>up</em> when more probability flows <em>in</em> than flows <em>out</em>, and goes <em>down</em> when more flows <em>out</em> than flows <em>in</em>.</p> </blockquote> <p>That “more in than out” statement is exactly what the \(-\nabla\!\cdot \mathbf{J}_{\text{adv}}\) term encodes.</p> <p>The time evolution of the density \(p_t\), governed by the Fokker–Planck equation, can be visualized in the GIF below:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/fokker_planck_gmm_to_equilibrium-480.webp 480w,/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/fokker_planck_gmm_to_equilibrium-800.webp 800w,/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/fokker_planck_gmm_to_equilibrium-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/fokker_planck_gmm_to_equilibrium.gif" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="enter-the-noise">Enter the Noise</h2> <p>So far we only had <em>pure motion</em>: each particle follows the deterministic flow \(\mathbf{v}_t\), and density changes only because mass is carried from place to place. That is exactly what the continuity equation states. It is just the change-of-variable idea applied <em>continuously</em>: as points move, the density reshapes to conserve total probability.</p> <p>The forward diffusion process keeps the same “move points, update density” picture, but adds one extra ingredient: each point also gets a tiny Gaussian jitter. If we take a cloud of particles and continuously give every particle a small random wiggle, the cloud becomes <em>more spread out</em> over time. Two particles that start very close will typically drift apart. As a result, probability does not only <em>shift</em> due to the drift; it also <em>spreads</em> from dense regions into nearby less-dense regions. This is what the extra noise term captures at the density level: it adds a second contribution to the flux that pushes mass from high density toward low density.</p> <p>A convenient way to say this without changing the logic is: we still track density by the same conservation law, but now there are two ways mass can cross space. One is the usual “carried by motion” flow,</p> \[\mathbf{J}_{\text{adv}}(\mathbf{x},t) = p_t(\mathbf{x})\,\mathbf{f}_t(\mathbf{x}),\] <p>and the other is a “spreading” flow caused by the jitters, which pushes mass from high density to low density,</p> \[\mathbf{J}_{\text{spread}}(\mathbf{x},t) = -\frac{1}{2}g^2(t)\,\nabla_{\mathbf{x}}p_t(\mathbf{x}).\] <p>Add these two contributions, and apply the same net-outflow rule as in the continuity equation:</p> <div style="background:rgba(255,165,0,0.12); padding:12px; border-radius:10px; max-width:100%; overflow-x:auto; overflow-y:hidden;"> $$ \frac{\partial p_t(\mathbf{x})}{\partial t} = -\nabla_{\mathbf{x}}\cdot\Big(\mathbf{J}_{\text{move}}(\mathbf{x},t)+\mathbf{J}_{\text{spread}}(\mathbf{x},t)\Big) = -\nabla_{\mathbf{x}}\cdot\bigl(\mathbf{f}_t(\mathbf{x})\,p_t(\mathbf{x})\bigr) +\frac{1}{2}g(t)^2\,\Delta_{\mathbf{x}}p_t(\mathbf{x}). $$ </div> <p>This equation is the formal way to say: drift moves the probability cloud, and Gaussian jitters blur it.</p> <p>Let us revisit how the change-of-variable story shows up inside diffusion models.</p> <p>In diffusion models, no matter which viewpoint we take (DDPM, Score SDE, or Flow Matching), we first choose the forward noise-injection rule ourselves. Concretely, we fix Gaussian conditionals such as \(p(\mathbf{x}_t\mid \mathbf{x}_0)=\mathcal{N}(\mathbf{x}_t;\alpha_t\mathbf{x}_0,\sigma_t^2\mathbf{I}),\) which tells us what a clean sample looks like after we inject noise up to time \(t\). That single choice pins down a whole movie of <em>snapshot marginals</em> \(p_t\), starting at the data distribution and ending near a simple noise distribution. In continuous time, the density-level bookkeeping of this movie is captured by the Fokker–Planck equation: it is the change-of-variables rule for a cloud of particles that both moves and spreads.</p> <p>The reverse-time generation step is then built to play the same movie reversely. We start from noise and update the sample step by step (by solving the PF-ODE), while remaining consistent with <em>the same</em> snapshot path \(p_t\) along the way.</p> <hr> <h1 id="iii-from-slow-samplers-to-flow-maps">III. From Slow Samplers to Flow Maps</h1> <p>So far, everything we have discussed shares a common engineering drawback: <em>sampling is iterative</em>. Turning a single draw of Gaussian noise into a realistic sample typically requires dozens to hundreds of neural network evaluations, because we must integrate the reverse-time dynamics step by step.</p> <p>This raises a natural question:</p> <blockquote> <p>Can we design a standalone generative principle that trains in a stable way, and samples quickly?</p> </blockquote> <p>One promising answer is the family of <strong>flow map models</strong> <d-cite key="boffi2024flow"></d-cite>.</p> <h2 id="what-is-a-flow-map-model">What Is a Flow Map Model?</h2> <p>Recall the PF-ODE viewpoint: there exists an <em>ideal</em> drift field \(\mathbf{v}(\mathbf{x},t)\) whose trajectories reproduce the prescribed snapshot marginals defined by the forward noising process. A deterministic sample path follows</p> \[\frac{\mathrm{d}\mathbf{x}(u)}{\mathrm{d}u} = \mathbf{v}\bigl(\mathbf{x}(u),u\bigr).\] <p>If we start from a state \(\mathbf{x}_s\) at time \(s\) and let the dynamics run until time \(t\), the state lands at some new point \(\mathbf{x}_t\). This “take me from \(s\) to \(t\)” transformation is a <em>time-jump operator</em>: it tells us where a point ends up after evolving for a while. We call this operator the <em>flow map</em>, and write it as</p> \[\Psi_{s\to t}(\mathbf{x}_s) = \mathbf{x}_s+\int_s^t \mathbf{v}\bigl(\mathbf{x}(u),u\bigr)\,\mathrm{d}u.\] <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/flow-map.svg" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/flow-map.svg" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>It answers one concrete question: <em>starting from the current noisy state, where would the ideal dynamics place me at a later time?</em> Standard samplers approximate this jump by chaining many tiny solver steps. A flow map model tries to learn the jump <em>directly</em>:</p> \[\mathbf{G}_\theta(\mathbf{x}_s,s,t)\approx \Psi_{s\to t}(\mathbf{x}_s).\] <p>If we could query the true <em>time-jump</em> \(\Psi_{s\to t}\), the training story would be almost too simple: we would just regress to the oracle target. Concretely, we would sample a start time \(s\), an end time \(t\), draw a point \(\mathbf{x}_s\sim p_s\), and train a model \(\mathbf{G}_\theta\) to predict where that point should land after evolving from \(s\) to \(t\):</p> <div style="background:rgba(255,165,0,0.12); padding:12px; border-radius:10px; max-width:100%; overflow-x:auto; overflow-y:hidden;"> $$ \mathcal{L}_{\text{oracle}}(\theta) = \mathbb{E}_{s,t}\,\mathbb{E}_{\mathbf{x}_s\sim p_s} \Bigl[ w(s,t)d\bigl(\mathbf{G}_\theta(\mathbf{x}_s,s,t),\,\Psi_{s\to t}(\mathbf{x}_s)\bigr) \Bigr]. $$ </div> <p>Here \(d(\cdot,\cdot)\) is simply a distance-like measurement (e.g., MSE), and \(w(s,t)\) is a time-weighting function. At the optimum, \(\mathbf{G}_\theta(\mathbf{x}_s,s,t)\) would match the oracle jump \(\Psi_{s\to t}(\mathbf{x}_s)\), so generation becomes a few large, accurate jumps rather than a long chain of tiny updates. In the most extreme case, we could even do one-step generation: first draw a prior sample \(\mathbf{x}_T \sim p_{\text{prior}}\), then map it straight to data with</p> \[\mathbf{G}_\theta(\mathbf{x}_T, T, 0).\] <p>The snag is that \(\Psi_{s\to t}\) is not available in closed form. So the real design problem is: <em>how do we create practical targets that still point toward the same oracle objective?</em> The cleanest guiding structure is a property that true flow maps must satisfy.</p> <h2 id="three-flow-map-families-as-three-handles-on-the-same-oracle">Three Flow Map Families as Three “Handles” on the Same Oracle</h2> <h3 id="consistency-models-cm-">Consistency Models (CM) <d-cite key="song2023consistency"></d-cite>.</h3> <p>Since our end goal is a clean sample, CM fixes the terminal time at \(0\) and only focuses on the special jumps \(\Psi_{s\to 0}\). The ideal picture is straightforward: given a noisy state \(\mathbf{x}_s\), we would like a denoiser that directly returns where the <em>true</em> dynamics would land at time \(0\),</p> \[\mathbf{f}_\theta(\mathbf{x}_s,s)\approx \Psi_{s\to 0}(\mathbf{x}_s).\] <p>If that oracle target were available, training would reduce to plain regression: sample a time \(s\), draw \(\mathbf{x}_s\sim p_s\), and penalize the mismatch (with a time weight \(w(s)\) and a distance-like measure \(d\)):</p> \[\mathcal{L}_{\text{oracle-CM}}(\theta) = \mathbb{E}_{s}\,\mathbb{E}_{\mathbf{x}_s\sim p_s} \Bigl[ w(s)\,d\bigl(\mathbf{f}_\theta(\mathbf{x}_s,s),\,\Psi_{s\to 0}(\mathbf{x}_s)\bigr) \Bigr].\] <p>But in practice the oracle flow map \(\Psi_{s\to 0}\) is not something we can query. CM gets around this with one simple idea: <em>self-consistency</em>, which is really a flow-map property. Under standard ODE conditions, solutions are <em>unique</em>, so each initial state maps to a unique state at time $t$ by the flow map. Equivalently, flow maps must <em>compose</em>: going from \(s\) to \(0\) is the same as going from \(s\) to \(s-\Delta s\) and then from \(s-\Delta s\) to \(0\). As a result, any two states on the same trajectory, say \(\mathbf{x}_s\) and its backstep \(\Psi_{s\to s-\Delta s}(\mathbf{x}_s)\), must share the same endpoint at time \(0\). This is exactly what we exploit to replace the missing oracle target with a stop-gradient <em>self-target</em> \(\mathbf{f}_{\theta^-}\) computed from the nearby state closer to \(0\):</p> \[\Psi_{s\to 0}(\mathbf{x}_s) \;\approx\; \Bigl(\mathbf{f}_{\theta^-}(\Psi_{s\to s-\Delta s}(\mathbf{x}_s),\,s-\Delta s)\Bigr), \qquad \Delta s&gt;0.\] <p>So the whole method boils down to one practical step: <em>how do we get a proxy \(\widehat{\mathbf{x}}_{s-\Delta s}\) for the inaccessible backstep \(\Psi_{s\to s-\Delta s}(\mathbf{x}_s)\)?</em> There are two standard routes.</p> <p>In <em>distillation</em>, we obtain the intermediate state by explicitly taking one reverse-time solver step driven by a pre-trained diffusion teacher. Concretely, starting from the current state \(\mathbf{x}_s\), we take</p> \[\widehat{\mathbf{x}}_{s-\Delta s} = \text{one solver step using the teacher, from } s \text{ to } s-\Delta s\] <p>meaning that \(\widehat{\mathbf{x}}_{s-\Delta s}\) is the result of a single numerical update (e.g., Euler) from time \(s\) to \(s-\Delta s\) using the teacher diffusion model as the PF-ODE drift.</p> <p>In <em>from scratch</em> training, we build the intermediate state directly from the forward-corruption rule: if \(\mathbf{x}_s\) was formed from the same clean sample \(\mathbf{x}_0\) and noise \(\boldsymbol{\epsilon}\), then we can reuse them to “rewind” to the slightly less-noisy time \(s-\Delta s\):</p> \[\widehat{\mathbf{x}}_{s-\Delta s} = \alpha_{s-\Delta s}\mathbf{x}_0 + \sigma_{s-\Delta s}\boldsymbol{\epsilon}.\] <p>Once we have this proxy point, CM training becomes a fully practical regression against a stop-gradient self-target, replacing the inaccessible oracle map inside the original objective.</p> <h3 id="consistency-trajectory-models-ctm-">Consistency Trajectory Models (CTM) <d-cite key="kim2023consistency"></d-cite>.</h3> <p>CTM aims to learn the <em>general</em> flow map \(\Psi_{s\to t}\), but it does so with an Euler-flavored parameterization that makes the model behave like a solver step. The starting point is the flow map form</p> \[\Psi_{s\to t}(\mathbf{x}_s)=\mathbf{x}_s+\int_s^t \mathbf{v}(\mathbf{x}(u),u)\,\mathrm{d}u,\] <p>and the key move is to rewrite this jump as a weighted blend of the input \(\mathbf{x}_s\) and a residual term:</p> \[\Psi_{s\to t}(\mathbf{x}_s) = \frac{t}{s}\,\mathbf{x}_s + \Bigl(1-\frac{t}{s}\Bigr)\,\mathbf{g}(\mathbf{x}_s,s,t), \qquad \mathbf{g}(\mathbf{x}_s,s,t) := \mathbf{x}_s+\frac{s}{s-t}\int_s^t \mathbf{v}(\mathbf{x}(u),u)\,\mathrm{d}u.\] <p>This motivates a solver-like parameterization for the learned jump:</p> <p>\(\mathbf{G}_\theta(\mathbf{x}_s,s,t) := \frac{t}{s}\,\mathbf{x}_s + \Bigl(1-\frac{t}{s}\Bigr)\,\mathbf{g}_\theta(\mathbf{x}_s,s,t),\) where \(\mathbf{g}_\theta\) is aimed to approximate the residual term \(\mathbf{g}(\mathbf{x}_s,s,t)\):</p> \[\mathbf{g}_\theta \approx \mathbf{g}.\] <p>A nice side-effect is that the boundary condition comes for free. Plugging in \(t=s\) makes the mixing weight vanish, so</p> \[\mathbf{G}_\theta(\mathbf{x}_s,s,s)=\mathbf{x}_s,\] <p>without any special constraint during training.</p> <p>This parameterization is useful because the residual \(\mathbf{g}\) has a clean meaning in the small-step limit. As \(t\to s\), the flow-map integral collapses to an Euler-sized move, and \(\mathbf{g}(\mathbf{x}_s,s,t)\) approaches</p> \[\mathbf{g}(\mathbf{x}_s,s,t) = \mathbf{x}_s - s\,\mathbf{v}(\mathbf{x}_s,s) + \mathcal{O}(|t-s|).\] <p>So learning \(\mathbf{g}\) does two jobs at once: it supports <em>finite</em> jumps \(s\to t\), and it also encodes the <em>instantaneous</em> drift through the infinitesimal limit. In particular, evaluating the network at “same time” gives a direct drift estimate,</p> \[\mathbf{v}(\mathbf{x}_s,s)\;\approx\;\frac{\mathbf{x}_s-\mathbf{g}_\theta(\mathbf{x}_s,s,s)}{s}.\] <p>This is why \(\mathbf{g}_\theta(\cdot,s,s)\) matters in CTM: it acts as a local direction field that we can reuse to build short moves and form training targets.</p> <p>CTM extends CM’s <em>self-consistency</em> into the natural flow-map principle called the <em>semigroup property</em>. The idea is simple: a long jump should agree with two shorter jumps stitched together. Concretely, for any intermediate time \(u\) between \(s\) and \(t\), the true flow maps satisfy</p> \[\Psi_{s\to t} \;=\; \Psi_{u\to t}\circ \Psi_{s\to u}.\] <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/semigroup.svg" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/semigroup.svg" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>So CTM enforces the same idea with its learned map: a <em>big jump</em> should agree with <em>two smaller jumps</em> stitched at \(u\). Since the oracle maps are unavailable, CTM uses a stop-gradient self-target:</p> \[\Psi_{s\to t}(\mathbf{x}_s) \;\approx\; \mathbf{G}_{\theta^-}\Bigl(\Psi_{s\to u}(\mathbf{x}_s),\,u,\,t\Bigr),\] <p>Finally, \(\Psi_{s\to u}(\mathbf{x}_s)\) can be approximated in two ways. In <em>distillation</em>, we compute it by running a few solver steps of a pre-trained diffusion teacher, starting from \(\mathbf{x}_s\) and integrating from time \(s\) to time \(u\):</p> \[\Psi_{s\to u}(\mathbf{x}_s) \approx \text{few solver steps using the pre-trained diffusion teacher, from } s \text{ to } u.\] <p>In <em>from scratch</em> training, because \(\mathbf{g}_\theta(\cdot,s,s)\) reproduces the instantaneous drift of PF-ODE, we approximate \(\Psi_{s\to u}(\mathbf{x}_s)\) using CTM itself by rolling out a short self-teacher trajectory driven by the local drift implied by \(\mathbf{g}_\theta(\cdot,s,s)\):</p> \[\Psi_{s\to u}(\mathbf{x}_s) \approx \text{few solver steps using } \mathbf{g}_\theta(\cdot,s,s) \text{ from } s \text{ to } u.\] <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/ctm-target.svg" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-tracing-principles-behind-modern-diffusion-models/ctm-target.svg" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h3 id="mean-flow-mf-">Mean Flow (MF) <d-cite key="geng2025mean"></d-cite>.</h3> <p>MF keeps the same end goal of fast, accurate jumps for learning the <em>general</em> flow map \(\Psi_{s\to t}\), but it changes <em>what</em> the network predicts and <em>how</em> it is trained compared to CTM. Instead of outputting the endpoint jump directly, MF asks for an <em>average integration</em> over the interval, which we can view as the average slope of the flow map:</p> \[\mathbf{h}(\mathbf{x}_s,s,t) := \frac{1}{t-s}\int_s^t \mathbf{v}\bigl(\mathbf{x}(u),u\bigr)\,\mathrm{d}u, \qquad \mathbf{h}_\theta(\mathbf{x}_s,s,t)\approx \mathbf{h}(\mathbf{x}_s,s,t).\] <p>Once we have this slope-like quantity, the jump is recovered by a simple reconstruction:</p> \[\Psi_{s\to t}(\mathbf{x}_s)\approx \mathbf{x}_s+(t-s)\,\mathbf{h}_\theta(\mathbf{x}_s,s,t).\] <p>This is often <em>easier to learn</em> in practice: predicting an average drift is like learning a reliable slope that can be reused across different step sizes, instead of chasing a single fragile endpoint.</p> <p>MF still needs supervision, so the question is how to build a usable target for \(\mathbf{h}\). The key is a small calculus fact. Starting from the definition</p> \[(t-s)\,\mathbf{h}(\mathbf{x}_s,s,t)=\int_s^t \mathbf{v}\bigl(\mathbf{x}(u),u\bigr)\,\mathrm{d}u,\] <p>we differentiate both sides with respect to the start time \(s\). Two things then happen at once: the interval length changes, and the starting state \(\mathbf{x}_s\) itself slides along the trajectory with</p> \[\frac{\mathrm{d}}{\mathrm{d}s}\mathbf{x}_s=\mathbf{v}(\mathbf{x}_s,s).\] <p>Putting these together yields an identity that expresses the average slope in terms of the <em>instantaneous drift</em> at \(s\), plus correction terms involving the derivatives of \(\mathbf{h}\):</p> \[\mathbf{h}(\mathbf{x}_s,s,t) = \mathbf{v}(\mathbf{x}_s,s) - (s-t)\Bigl( \mathbf{v}(\mathbf{x}_s,s)\,\partial_{\mathbf{x}} \mathbf{h}(\mathbf{x}_s,s,t) + \partial_{s} \mathbf{h}(\mathbf{x}_s,s,t) \Bigr).\] <p>This is the <em>MF identity</em> handle: it turns an integral quantity into a local relation we can enforce during training.</p> <p>Therefore, MF turns the MF identity into a practical training signal by <em>freezing</em> the derivative terms with a stop-gradient copy \(\mathbf{h}_{\theta^-}\). This gives us a usable proxy for the oracle mean flow \(\mathbf{h}\):</p> \[\mathbf{h}(\mathbf{x}_s,s,t) \approx \mathbf{v}(\mathbf{x}_s,s) - (s-t)\Bigl( \mathbf{v}(\mathbf{x}_s,s)\,\partial_{\mathbf{x}} \mathbf{h}_{\theta^-}(\mathbf{x}_s,s,t) + \partial_{s} \mathbf{h}_{\theta^-}(\mathbf{x}_s,s,t) \Bigr).\] <p>MF still needs the oracle instantaneous drift \(\mathbf{v}(\mathbf{x}_s,s)\). In practice we plug in an estimate \(\widehat{\mathbf{v}}(\mathbf{x}_s,s)\) in one of two ways. With (i) <em>distillation</em>, a pre-trained diffusion model provides this velocity estimate. With (ii) <em>from scratch</em> training, we use the forward-corruption rule itself: if \(\mathbf{x}_s\) was generated from a clean sample \(\mathbf{x}_0\) using the same noise draw \(\boldsymbol{\epsilon}\), then the conditional mean path implies a closed-form velocity at time \(s\), giving a direct estimate</p> \[\widehat{\mathbf{v}}(\mathbf{x}_s,s)=\alpha_s'\mathbf{x}_0 +\sigma_s' \boldsymbol{\epsilon}.\] <p>Putting these together yields MF’s final regression target, a fully practical proxy for \(\mathbf{h}(\mathbf{x}_s,s,t)\):</p> \[\mathbf{h}_{\theta^-}^{\text{tgt}}(\mathbf{x}_s,s,t) := \widehat{\mathbf{v}}(\mathbf{x}_s,s) - (s-t)\Bigl( \widehat{\mathbf{v}}(\mathbf{x}_s,s)\,\partial_{\mathbf{x}} \mathbf{h}_{\theta^-}(\mathbf{x}_s,s,t) + \partial_{s} \mathbf{h}_{\theta^-}(\mathbf{x}_s,s,t) \Bigr).\] <h2 id="how-the-three-flow-map-models-relate-">How the Three Flow Map Models Relate <d-cite key="lai2025principles"></d-cite> </h2> <p>CTM contains CM as a special anchored case. If CTM always fixes the terminal time to \(t=0\), then it only needs to learn the maps \(\Psi_{s\to 0}\), which is exactly the CM setting.</p> <p>More broadly, CTM and MF are <em>mathematically related</em>: they aim at the same oracle flow map, but they choose different parameterizations of the same jump. One way to see this is to rewrite the same map \(\Psi_{t\to s}(\mathbf{x}_t)\) in two equivalent-looking forms:</p> \[\Psi_{t\to s}(\mathbf{x}_t) = \frac{s}{t}\mathbf{x}_t + \frac{t-s}{t}\underbrace{\Bigl[\mathbf{x}_t+\frac{t}{t-s}\int_t^s \mathbf{v}(\mathbf{x}_u, u)\,\mathrm{d}u\Bigr]}_{\approx\,\mathbf{g}_\theta} = \mathbf{x}_t + (s-t)\underbrace{\Bigl[\frac{1}{s-t}\int_t^s \mathbf{v}(\mathbf{x}_u, u)\,\mathrm{d}u\Bigr]}_{\approx\,\mathbf{h}_\theta}.\] <p>Beyond being <em>mathematically related</em> at the level of parameterization, CTM and MF objectives are also connected. We start from the raw squared error</p> \[\bigl\|\mathbf{G}_\theta(\mathbf{x}_t,t,s)-\Psi_{t\to s}(\mathbf{x}_t)\bigr\|_2^2.\] <p>Using the CTM parameterization and a matching oracle decomposition, we have</p> \[\mathbf{G}_\theta(\mathbf{x}_t,t,s) = \frac{s}{t}\mathbf{x}_t+\frac{t-s}{t}\,\mathbf{g}_\theta(\mathbf{x}_t,t,s), \qquad \Psi_{t\to s}(\mathbf{x}_t) = \frac{s}{t}\mathbf{x}_t+\frac{t-s}{t}\Bigl(\mathbf{x}_t+\frac{t}{t-s}\int_t^s \mathbf{v}(\mathbf{x}_u,u)\,\mathrm{d}u\Bigr).\] <p>The common base term \(\frac{s}{t}\mathbf{x}_t\) cancels, so the squared error factors into a scale term and a residual mismatch:</p> \[\bigl\|\mathbf{G}_\theta(\mathbf{x}_t,t,s)-\Psi_{t\to s}(\mathbf{x}_t)\bigr\|_2^2 = \Bigl(\frac{t-s}{t}\Bigr)^2 \Bigl\| \mathbf{g}_\theta(\mathbf{x}_t,t,s) - \Bigl(\mathbf{x}_t+\frac{t}{t-s}\int_t^s \mathbf{v}(\mathbf{x}_u,u)\,\mathrm{d}u\Bigr) \Bigr\|_2^2.\] <p>To relate this to MF, we consider the following network re-parametrization</p> \[\mathbf{g}_\theta(\mathbf{x}_t,t,s):=\mathbf{x}_t-t\,\mathbf{h}_\theta(\mathbf{x}_t,t,s).\] <p>Inside the norm, the \(\mathbf{x}_t\) terms cancel again, leaving an error purely in the averaged quantity:</p> \[\Bigl\| \mathbf{g}_\theta(\mathbf{x}_t,t,s) - \Bigl(\mathbf{x}_t+\frac{t}{t-s}\int_t^s \mathbf{v}(\mathbf{x}_u,u)\,\mathrm{d}u\Bigr) \Bigr\|_2^2 = t^2\Bigl\| \mathbf{h}_\theta(\mathbf{x}_t,t,s) - \Bigl(\frac{1}{s-t}\int_t^s \mathbf{v}(\mathbf{x}_u,u)\,\mathrm{d}u\Bigr) \Bigr\|_2^2.\] <p>Multiplying by the prefactor gives</p> \[\bigl\|\mathbf{G}_\theta(\mathbf{x}_t,t,s)-\Psi_{t\to s}(\mathbf{x}_t)\bigr\|_2^2 = (t-s)^2 \Bigl\| \mathbf{h}_\theta(\mathbf{x}_t,t,s) - \Bigl(\frac{1}{s-t}\int_t^s \mathbf{v}(\mathbf{x}_u,u)\,\mathrm{d}u\Bigr) \Bigr\|_2^2.\] <p>In words, CTM measures error in “residual coordinates” \(\mathbf{g}_\theta\), while MF measures error in “average-slope coordinates” \(\mathbf{h}_\theta\). The algebra shows these objectives are <em>mathematically related</em>, differing only by a time-dependent scaling of scale \(t^2\).</p> <p>Flow map models all target the same underlying object: the <em>oracle flow map</em> \(\Psi_{s\to t}\) that moves probability mass along the ideal PF-ODE. What differs is <em>which handle</em> we use to learn that map without ever querying it directly. The punchline is that CM, CTM, MF are not three unrelated recipes. They are three ways to learn the same oracle flow map using different parameterizations and different self-contained training signals. In practice, this is exactly how we turn “many tiny solver steps” into “a few accurate jumps” while staying faithful to the same density-evolution story we started from: move particles, conserve probability, and learn the map that performs the transport.</p> <hr> <h1 id="conclusion-one-story-many-lenses-and-the-road-to-fast-generators">Conclusion: One Story, Many Lenses, and the Road to Fast Generators</h1> <p>Modern diffusion models can look like a zoo of acronyms, but the underlying story is surprisingly simple. At heart, they are all ways to <em>transport probability mass</em> from a simple Gaussian distribution to the complicated data distribution progressively. Once you see generation as a <em>moving cloud of particles</em>, the math stops being mysterious: it is really just different forms of <em>time-varying change-of-variables</em>.</p> <p>From there, variational based, score-based, and flow-based diffusions differ less than their names suggest. They all <em>choose the same forward Gaussian snapshots</em> and then ask the network to predict <em>different but equivalent handles</em> on the reverse-time dynamics. What makes training workable in all three cases is the same move: the <em>conditional trick</em>. We replace an intractable marginal target (reverse kernel / score / velocity under \(p_t\)) with a tractable conditional target under \(p(\mathbf{x}_t\mid \mathbf{x}_0)\), turning challenging problems into “solve a supervised regression problem”.</p> <p>But diffusion’s classic payoff, high-fidelity samples, comes with a classic cost: <em>iterative sampling</em>. If we must integrate the reverse dynamics in many small steps, generation stays slow. Flow map models push the same diffusion template one step further: instead of learning <em>infinitesimal</em> updates and then integrating them, they aim to learn <em>time-jumps</em> of the PF-ODE directly. In other words, they try to approximate the map \(\Psi_{s\to t}\) itself, so we can replace long chains of tiny steps with a handful of large, accurate jumps. CM, CTM, and MF are three concrete “handles” on this idea: each enforcing underlying flow-map structures to manufacture practical targets when the oracle flow map is unavailable.</p> <p>Stepping back, the big takeaway is optimistic: diffusion models are not a single method, but a <em>principle for building generators</em> from a prescribed forward path. Once we commit to “choose a forward corruption, then learn its reverse transport”, there is room for many designs that trade off <em>stability</em>, <em>fidelity</em>, and <em>speed</em>. Flow maps are one promising direction, but likely not the last word. The exciting open space is to keep the same clean backbone: we define a forward transport process, and change-of-variables tells us how the distribution moves. Then we look for new <em>parameterizations</em> and <em>objectives</em>, which and make <em>fast generation</em> as reliable as the best step-by-step samplers.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/2026/assets/bibliography/2026-04-27-tracing-principles-behind-modern-diffusion-models.bib"></d-bibliography> <d-article> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/fans/">FANS - Frequency-Adaptive Noise Shaping for Diffusion Models</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-reversal-curse-from-general-domain-to-remote-sensing-images/">Visual Reversal Curse: From General Domain to Remote Sensing Images</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-long-context/">Text-to-Image compression for long context understanding</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/using-large-language-models-to-simulate-and-predict-human-decision-making/">Using Large Language Models to Simulate and Predict Human Decision-Making</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/useful-calibrated-uncertainties/">What (and What Not) are Calibrated Uncertainties Actually Useful for?</a> </li> <br> <br> </d-article> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 ICLR Blog. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/2026/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/2026/assets/js/distillpub/overrides.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/2026/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/2026/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/2026/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/2026/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/2026/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/2026/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/2026/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/2026/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/2026/assets/js/search-data.js"></script> <script src="/2026/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>