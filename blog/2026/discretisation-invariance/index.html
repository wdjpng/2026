<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Discretisation invariance | ICLR Blogposts 2026 </title> <meta name="author" content="ICLR Blog"> <meta name="description" content="Discretisation invariance, a recent innovation in scientific machine learning, is a requirement that ensures an architecture can process inputs of different resolutions. In this post, we formally define this property, provide examples, generate datasets, train architectures, and discuss whether discretisation invariance is living up to its promise."> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, icl# add your own keywords or leave empty"> <link rel="stylesheet" href="/2026/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/2026/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/2026/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/2026/assets/img/iclr_favicon.ico?0a8a3afdb0dbe139723b24dba3052a4f"> <link rel="stylesheet" href="/2026/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://iclr-blogposts.github.io/2026/blog/2026/discretisation-invariance/"> <script src="/2026/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/2026/assets/js/distillpub/template.v2.js"></script> <script src="/2026/assets/js/distillpub/transforms.v2.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Discretisation invariance",
            "description": "Discretisation invariance, a recent innovation in scientific machine learning, is a requirement that ensures an architecture can process inputs of different resolutions. In this post, we formally define this property, provide examples, generate datasets, train architectures, and discuss whether discretisation invariance is living up to its promise.",
            "published": "April 27, 2026",
            "authors": [
              
              {
                "author": "Anonymous",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2026/"> ICLR Blogposts 2026 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2026/">home </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/about/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/call/">call for blogposts </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/submitting/">submitting </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/reviewing/">reviewing </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2026/"><strong>2026</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2025/">2025</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2024/">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2023/">2023</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blog-track.github.io/home/" rel="external nofollow noopener" target="_blank">2022</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Discretisation invariance</h1> <p>Discretisation invariance, a recent innovation in scientific machine learning, is a requirement that ensures an architecture can process inputs of different resolutions. In this post, we formally define this property, provide examples, generate datasets, train architectures, and discuss whether discretisation invariance is living up to its promise.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#introduction-and-motivation">Introduction and motivation</a> </div> <div> <a href="#what-is-discretisation-invariance">What is discretisation invariance?</a> </div> <div> <a href="#examples-and-non-examples">Examples and non-examples</a> </div> <ul> <li> <a href="#fourier-neural-operator">Fourier Neural Operator</a> </li> <li> <a href="#convolutional-neural-networks">Convolutional neural networks</a> </li> <li> <a href="#deep-operator-network-with-linear-observations">Deep Operator Network with linear observations</a> </li> <li> <a href="#pca-net">PCA-Net</a> </li> <li> <a href="#neural-fields">Neural fields</a> </li> <li> <a href="#graph-neural-networks">Graph neural networks</a> </li> <li> <a href="#graph-kernel-networks">Graph kernel networks</a> </li> </ul> <div> <a href="#training-and-evaluation">Training and evaluation</a> </div> <div> <a href="#the-role-of-discretisation-invariance">The role of discretisation invariance</a> </div> <ul> <li> <a href="#arguments-against-discretisation-invariance">Arguments against discretisation invariance</a> </li> <li> <a href="#arguments-in-favour-of-discretisation-invariance">Arguments in favour of discretisation invariance</a> </li> </ul> <div> <a href="#discussion">Discussion</a> </div> </nav> </d-contents> <h2 id="introduction-and-motivation">Introduction and motivation</h2> <p>Partial differential equations (PDEs) are the gold standard in scientific modelling. With rare exceptions, PDEs are solved numerically, and the goal is always to develop a reliable, accurate algorithm that delivers a solution as cheaply as possible. Neural networks were first explored as a solution method starting at least from the 1990s <d-cite key="lee1990neural"></d-cite>, <d-cite key="lagaris1998artificial"></d-cite>. Over time, these methods converged to two dominant paradigms: physics-informed neural networks (PINNs, <d-cite key="lagaris1998artificial"></d-cite>, <d-cite key="raissi2017physics"></d-cite>) and operator learning <d-cite key="kovachki2023neural"></d-cite>, <d-cite key="lu2021learning"></d-cite>. PINNs is an unsupervised techniques that directly aims to solve PDE. Operator learning, the approach we consider here, is a supervised technique aiming to amortize the cost of parametric PDE solution in the “multi-query setting”. We explain the setup of operator learning below.</p> <p>We start by specifying a model of interest in the form of PDE. For the sake of example we consider stationary diffusion equation</p> \[\begin{aligned} &amp;\frac{\partial}{\partial \boldsymbol{x}_{1}}\left(k(\boldsymbol{x})\frac{\partial}{\partial \boldsymbol{x}_{1}} u(\boldsymbol{x})\right)+\frac{\partial}{\partial \boldsymbol{x}_{2}}\left(k(\boldsymbol{x})\frac{\partial}{\partial \boldsymbol{x}_{2}} u(\boldsymbol{x})\right) = f(\boldsymbol{x}),\\ &amp;\boldsymbol{x}\in\Gamma=(0, 1)^2,\,\left.u(\boldsymbol{x})\right|_{\boldsymbol{x}\in\partial\Gamma} = 0. \end{aligned}\] <p>This PDE naturally appears in modelling of multiphase fluid flow, heat conduction and electrostatic problems in heterogeneous media.</p> <p>PDE contains two parameters: diffusivity coefficient $k(\boldsymbol{x}) &gt; 0$ and the source term $f(\boldsymbol{x})$. We assume that we need to solve the stationary diffusion equation repeatedly for a large set of parameters drawn from a joint probability distribution $k(\boldsymbol{x}), f(\boldsymbol{x}) \sim p_{f, k}$. One may simply call a classical solver for each new pair of parameters, but it can be more advantageous to exploit information recovered from already obtained solutions.</p> <p>This can be done in a standard regression framework: collect dataset $\left(f_1, k_1, u_1\right), \dots, \left(f_{M}, k_{M}, u_{M}\right)$, select parametric model $\mathcal{N}_{\theta}$ and train it with $L_2$ loss function</p> \[\begin{aligned} \theta^{\star} &amp;= \arg\min_{\theta}\mathbb{E}_{k, f\sim p_{k, f}}\left\|\mathcal{N}_{\theta}(k, f) - u\right\|_2^2 \\ &amp;\simeq \arg\min_{\theta} \frac{1}{N}\sum_{i=1}^{N}\left\|\mathcal{N}_{\theta}(k_i, f_i) - u_i\right\|_2^2. \end{aligned}\] <p>All standard techniques of machine learning apply: cross-validation, gradient descent methods, regularisation, etc.</p> <p>When PDE is discretised, continuous physical fields $k(\boldsymbol{x}), f(\boldsymbol{x}), u(\boldsymbol{x})$ become matrices, e.g., $k_{ij} = k(\boldsymbol{x}_{ij})$ where $\boldsymbol{x}_{ij} = \left((\boldsymbol{x}_{1})_{i}, (\boldsymbol{x}_{2})_{j}\right)$ is a point on regular grid. In this case, the regression problem is conceptually similar to classical image to image tasks: segmentation, denoising, superresolution, etc.</p> <p>Recently, a group of researchers suggested that regression problem for PDEs involves more than learning an image-to-image map <d-cite key="li2020neural"></d-cite>, <d-cite key="li2020fourier"></d-cite>. They argued that primal objects are functions themselves, not merely a particular way they are summarised with finite data. For example, one may represent function $k(\boldsymbol{x})$ on the grid with $N\times N$ points, or on the grid with $2N\times 2N$ points, or as a set of coefficients $c_{i}$ in a finite series $k(\boldsymbol{x}) = \sum_{i, j=1}^{N} c_{i}\phi_{i}(\boldsymbol{x})$. While the particular representations are different, the underlying function $k(\boldsymbol{x})$ remains the same in all cases. This raises a key question: Is it possible to build a neural network that is, to a degree, agnostic to the choice of particular discretisation? The answer is positive, and the architectures exhibiting this desirable property are now called <em>discretisation invariant</em> or <em>discretisation agnostic</em>.</p> <p>In this note, we address several questions about discretisation invariance architectures:</p> <ol> <li>What is discretisation invariance? How to define it formally?</li> <li>How discretisation invariant architectures are built?</li> <li>Why is discretisation invariance important?</li> </ol> <h2 id="what-is-discretisation-invariance">What is discretisation invariance?</h2> <p>Intuitively, discretisation invariant architectures consistently map functions for different resolutions: when more details appear in the input, we expect to see more details in the output.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/waves-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/waves-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/waves-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/waves.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> An example of discretisation invariant map $\psi = \mathcal{F}(\phi)$. When input $\phi$ is available on the refined grid the output $\psi$ is refined too. </div> <p>To slightly formalise the illustration above we define sampling and interpolation operators.</p> <p>Sampling operator $\mathcal{S}_{N}:\mathcal{C}_{[0, 1]}\rightarrow \mathbb{R}^{N}$ takes function $f$ from the space of continuous functions $\mathcal{C}_{[0, 1]}$, and outputs its values on the uniform grid $x_{i} = i / (N-1),\,i=0,\dots,(N-1)$.</p> <p>Interpolation operator $\mathcal{I}_{N}:\mathbb{R}^{N}\rightarrow \mathcal{C}_{[0, 1]}$ performs an inverse operation: from a set of samples $f(x_i)$ it reconstructs function $\widetilde{f}$ by linear interpolation</p> \[\widetilde{f}(x) = \frac{f(x_{i}) (x_{i+1} - x) + f(x_{i+1}) (x - x_{i})}{x_{i+1} - x_{i}},\] <p>where $x \in[x_{i}, x_{i+1}]$.</p> <p>In general $f(x) \neq \mathcal{I}_{N}\left(\mathcal{S}_{N}(f)\right)(x)$ but as $N$ grows, composition $\mathcal{I}_{N}\mathcal{S}_{N}$ becomes closer to identity in the standard $L_2$ norm: $\lim\limits_{k\rightarrow\infty}\left|f - \mathcal{I}_{k}\mathcal{S}_{k} f\right|_2 = 0$.</p> <p>Having sampling $\mathcal{S}$ and interpolation $\mathcal{I}$ operators, we call map $F_{k}:\mathbb{R}^{k}\rightarrow \mathbb{R}^{k}$ discretisation invariant if sequence $\psi_k=\mathcal{I}_{k}\left(F_{k}\left(\mathcal{S}_{k}(\phi)\right)\right)$ converges to a unique element of space $\mathcal{C}_{[0, 1]}$ for each input $\phi$.</p> <p>Our definition requires several clarifications:</p> <ol> <li>We choose particular operators $\mathcal{S}_{k}$, $\mathcal{I}_{k}$ for the sake of example. In general we ask for $\mathcal{S}_{k}$ to extract finite amount of information from function, $\mathcal{I}_{k}$ to approximately restore original function from this information, and for $\mathcal{I}_{k} \mathcal{S}_{k}$ to converge to identity map.</li> <li>The operator $\mathcal{S}_{k}$ is analogous to encoder and $\mathcal{I}_{k}$ - to decoder. Unlike encoder and decoder $\mathcal{S}_{k}, \mathcal{I}_{k}$ are not learned.</li> <li>In current literature, $\mathcal{S}_{k}$ is always a sampling operator. Given that, discretisation invariance architectures are mainly architectures agnostic to the resolution of the input.</li> <li>We select $\mathcal{C}_{[0, 1]}$ space with $L_2$ norm for the sake of example. Function space and norm should be tailored to an intended application.</li> <li>When $\mathcal{S}_{k}$ and $\mathcal{I}_{k}$ are selected we can have a family of maps $F_{k}$ that always operate with finite amount of information for each $k$. Discretisation invariance is a requirement for the map $\mathcal{I}_{k}F_{k}\mathcal{R}_{k}$ to converge to a continuous operator $\mathcal{F}: \mathcal{C}_{[0, 1]} \rightarrow \mathcal{C}_{[0, 1]}$ between function spaces.</li> </ol> <p>To show that discretisation invariant operators exist, we provide a simple example from numerical analysis. Integral $G(x_i) = \int_{0}^{x_i} g(x)dx$ can be approximated with Riemann sum $G(x_i) \simeq \sum_{j=1}^{i}g(x_j)/(N-1)$. We can represent this approximation with sampling operator and linear operators $F_{k}$ given by $k\times k$ lower triangular matrices:</p> \[\left(F_{k}\right)_{ij} = \left\{ \begin{array}{ll} \frac{1}{k-1}, &amp; \text{if }i\leq j;\\ 0, &amp; \text{ otherwise}. \end{array} \right.\] <p>For continuous function $g$, composition of sampling, Riemann sum and interpolation $\mathcal{I}_{k}\left(F_{k}\left(\mathcal{S}_{k}g\right)\right)$ converges to antiderivative $G(x) = \int_{0}^{x}g(y)dy$.</p> <h2 id="examples-and-non-examples">Examples and non-examples</h2> <p>An example with antiderivative operator suggests a general strategy to design discretisation invariant architectures: formulate all operations on functions in continuous form and use discretisation techniques from numerical analysis to process functions consistently on grids with different resolutions <d-cite key="berner2025principled"></d-cite>, <d-cite key="li2020fourier"></d-cite>, <d-cite key="li2020neural"></d-cite>. Most discretisation invariant architectures that we describe in this section follow this general recipe.</p> <h3 id="fourier-neural-operator">Fourier Neural Operator</h3> <p>Fourier Neural Operator (FNO) is a most famous and successful example of discretisation invariant architecture <d-cite key="li2020fourier"></d-cite>. FNO is a feedforward neural network that uses three operations:</p> <ol> <li>Convolution with kernel size $1$. For input functions $v^{i}(x)$ with $N$ “channels”, the output is $\sum_{j=1}^{N}A_{ij}v^{j}(x)$.</li> <li>Pointwise nonlinear activation.</li> <li>Spectral convolution <d-cite key="rippel2015spectral"></d-cite> with truncation.</li> </ol> <p>Spectral convolution is the only operation with spatial transfer of information. It can be understood either as parametrization of convolution in the Fourier domain where convolution operator becomes diagonal <d-cite key="rippel2015spectral"></d-cite>, or as an efficient evaluation of integral operator $\int \sum_{j} s_{ij}(y - x;\theta) v^{j}(y) dy$ with particular kernel convenient for implementation. The kernel is chosen to be periodic finite bandwidth function, so the whole integral operator can be implemented in three stages:</p> <ol> <li>Fourier transform of the input with truncation $\hat{v}^{j}_{k} = \mathcal{F}(v^{j}(x))_{k},\,k=1,\dots,k_{\max}$.</li> <li>Linear operator diagonal in Fourier space $\hat{w}^{i}_{m} = \sum_{i} R_{ijm} \hat{v}^{j}_{m}$. Coefficients of tensor $R$ are learnable parameters.</li> <li>Inverse Fourier transformation with padding to restore original spatial shape $\mathcal{F}^{-1}\left(\hat{w}^{i}_{m}\right)$.</li> </ol> <p>Spectral convolution with truncation is discretisation invariant by construction, since it approximates continuous integral kernels with standard techniques from numerical analysis.</p> <p>Many other architectures follow similar design pattern, e.g., <d-cite key="tripura2022wavelet"></d-cite>, <d-cite key="gupta2021multiwavelet"></d-cite>, <d-cite key="tran2021factorized"></d-cite>, by either modifying the parametrisation of spectral convolution or replacing Fourier with other fast transformations.</p> <h3 id="convolutional-neural-networks">Convolutional neural networks</h3> <p>Architecture based on convolutional neural networks (CNNs), especially ResNet <d-cite key="he2016deep"></d-cite> and U-Net <d-cite key="ronneberger2015u"></d-cite>, are highly successful for operator learning problems <d-cite key="stachenfeld2021learned"></d-cite>, <d-cite key="raonic2023convolutional"></d-cite>. They are often applied in a form of “image-to-image” mappings, with both images being physical fields of interest computed on the uniform grids.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_conv-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_conv-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_conv-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_conv.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> For a convolution operator with kernel size $5\times5$, a regular point collects information from $5$ neighbours along each dimension (shaded area). When the grid is refined the receptive field of convolution shrinks, so each point receives data from a smaller patch of $(x, y)$ space. </div> <p>What makes convolutional architectures interesting in our context is their ability to process inputs of different resolutions. However, as illustrated in the image above, the receptive field of CNNs in coordinate space will decrease with the increase of resolution. We will see below, that when CNN is trained on fixed resolution, data on refined grid appears as out-of-distribution, leading to sharp drop in accuracy. As a result discretisation invariance is not observed.</p> <h3 id="deep-operator-network-with-linear-observations">Deep Operator Network with linear observations</h3> <p>Deep Operator Network (DeepONet) is a meta-architecture <d-cite key="lu2019deeponet"></d-cite> based on the universal approximation results for operator learning <d-cite key="chen1995universal"></d-cite>. The architecture consists of two arbitrary neural networks: branch network and trunk network. For the input function $v(x)$, the output $u(x)$ is computed as follows:</p> <ol> <li>Branch net $b$ takes whatever information about $v(x)$ is available (e.g., finite number of samples at selected points $v(x_1),\dots, v(x_d)$) and outputs a set of coefficients $c_{1}, \dots, c_{b}$.</li> <li>The final layer of trunk net $t_{1}(x),\dots,t_{b}(x)$ provides a global basis that does not depend on the input $v(x)$.</li> <li>The output of the architecture is constructed from branch and trunk nets $u(x) = \sum_{i=1}^{b} c_{i}t_{i}(x)$.</li> </ol> <p>Readers familiar with reduced order modelling may recognise that the scheme closely resembles a non-intrusive proper orthogonal decomposition.</p> <p>To make discretisation invariant DeepONet, we select a set of predefined basis function $\psi_1(x),\dots,\psi_m(x)$, and use them to form linear observations $o_i = \int \psi_{i}(x) v(x) dx$ which are later supplied to branch net. To compute linear observations, any numerical integration can be applied, e.g., <a href="https://en.wikipedia.org/wiki/Trapezoidal_rule" rel="external nofollow noopener" target="_blank">trapezoidal rule</a>.</p> <h3 id="pca-net">PCA-Net</h3> <p>PCA-Net is encoder-processor-decoder architecture based on proper-orthogonal decomposition (POD) or Karhunen–Loève expansion <d-cite key="hesthaven2018non"></d-cite>, <d-cite key="bhattacharya2021model"></d-cite>. For input $v(x)$ we compute output $u(x)$ as follows:</p> <ol> <li>Encoder finds coefficients $c = \inf_{c} \left|v(x) - \sum_{i=1}^{d} c_i\phi_i(x)\right|_2^2$, where $\phi_i(x)$ are precomputed as explained below.</li> <li>Processor is a standard feedforward architecture that transforms a vector of coefficients to another vector $d_i,i=1,\dots m$.</li> <li>Similar to DeepONet, decoder computes a linear combination $u(x) = \sum_{i=1}^{m} d_i \psi_i(x)$, where $\psi_i(x)$ are computed similarly to $\phi_i(x)$.</li> </ol> <p>For PCA-Net functions $\phi_i(x)$, $\psi_i(x)$ are computed using POD <d-cite key="volkwein2013proper"></d-cite>. Let $v_{j}(x),\,j=1,\dots,N_{\text{train}}$ be inputs from the train set. Basis functions are recursively defined as solutions to optimisation problems</p> \[\begin{aligned} &amp;\psi_i(x) = \arg \min_{\psi} \sum_{j}\left\|v_{j} - \psi\left(\psi, v_{j}\right)\right\|_{2}^{2},\\ &amp;\text{s.t }\left\|\psi\right\|_2 = 1,\left(\psi_{k}, \psi\right) = 0,\text{ for }k &lt; i. \end{aligned}\] <p>That is, precisely the same way as principal components in PCA, but in functional space.</p> <h3 id="neural-fields">Neural fields</h3> <p>This is another example of encoder-processor-decoder architecture where both input and output are approximated by a form of implicit neural representation <d-cite key="serrano2023operator"></d-cite>. Operators based on neural fields work precisely as PCA-Net but uses different approach to represent functions by finite-dimensional vectors.</p> <p>To illustrate how basis functions are built, suppose we collected a dataset of inputs $v_i(x),\,i=1,\dots,N_{\text{train}}$. We select a neural network with weights $\theta$, that take coordinate $x$ in the first layer, and, in addition, vector $z$ in some hidden layer. We find parameters of the resulting architecture $\phi_{\theta}(x;z)$ by optimising the loss</p> \[\min_{\theta} \left(\sum_{i=1}^{N} \min_{z_i}\left\|\phi_{\theta}(x;z_i) - v_{i}(x)\right\|_{2}^2\right).\] <p>As a result for all dataset we will compute global parameters $\theta$ that are shared among samples $v_{i}$, and for each individual sample we find a coding vector $z_{i}$. This finite coding vector is used as a representation of function $v_i(x)$. For new inputs outside of the training set, the optimization problem above is solved with fixed $\theta$ to find finite-dimensional representation $z$. The same is done for the targets, and after that we are left with the problem of learning maps between finite dimension spaces.</p> <p>Note, that all operations in this scheme are formulated with no explicit discretisation, ensuring that the whole architecture is discretisation agnostic.</p> <h3 id="graph-neural-networks">Graph neural networks</h3> <p>Unstructured grids are very common in scientific computing, especially when complex geometries are involved. Given that, graph neural networks (GNNs) are a natural choice for building neural PDE solvers <d-cite key="brandstetter2022message"></d-cite>. GNN is an example of architecture that can handle variations in grid and geometry, but nonetheless is not discretisation invariant.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_GNN-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_GNN-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_GNN-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_GNN.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> An example of the receptive field for GNN. Similarly to CNN, receptive field shrinks when resolution is increased. </div> <p>The reason GNNs are not discretisation invariant is precisely the same as for CNNs: the architecture can be applied on a refined grid, but the receptive field is going to shrink leading to out of distribution inputs. The change in receptive field is illustrated in the picture above.</p> <h3 id="graph-kernel-networks">Graph kernel networks</h3> <p>Graph kernel network (GKN) is a discretisation agnostic version of GNN <d-cite key="li2020neural"></d-cite>. It replaces message passing by integral operator</p> \[v_{i+1}(\boldsymbol{x}) = \int_{B(\boldsymbol{x})} k_{\phi}(\boldsymbol{x}, \boldsymbol{y}, u(\boldsymbol{x}), u(\boldsymbol{y})) v_{i}(\boldsymbol{y}) d\boldsymbol{y},\] <p>where $v_{i+1}(\boldsymbol{x})$ is the output of the layer, $v_{i}(\boldsymbol{y})$ is an input, $B(\boldsymbol{x})$ is a ball of predefined radius around $\boldsymbol{x}$, and $u(\boldsymbol{x})$ is an input to the network, e.g., a diffusivity coefficient in stationary diffusion equation.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_KNN-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_KNN-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_KNN-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_KNN.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> For graph kernel networks, the receptive field, defined in $(x, y)$ space, is a hyperparameter of the architecture. When the grid is refined a graph of nearest neighbours is recomputed, ensuring discretisation invariance of the architecture. </div> <p>A convenient way to approximate integral above is to use Monte Carlo method</p> \[v_{i+1}(\boldsymbol{x}) = \frac{1}{N_{mc}}\sum_{l=1}^{N_{mc}} k_{\phi}(\boldsymbol{x}, \boldsymbol{y}_{l}, u(\boldsymbol{x}), u(\boldsymbol{y}_{l})) v_{i}(\boldsymbol{y}_{l}),\] <p>where $\boldsymbol{y}_{l}$ are points inside a ball $B(\boldsymbol{x})$ as shown in the figure above.</p> <p>Importantly, the radius of the ball $B(\boldsymbol{x})$ is not related to discretisation used, and because of that when the grid is refined the finite sum approximates the same integral using more terms.</p> <h2 id="training-and-evaluation">Training and evaluation</h2> <p>We demonstrate discretisation invariance on three architectures and two PDEs. The code is available <a href="https://github.com/4gnskq5g2s-collab/discretisation_invariance" rel="external nofollow noopener" target="_blank">in this repository</a>. Software used include jax <d-cite key="deepmind2020jax"></d-cite> and equinox <d-cite key="kidger2021equinox"></d-cite>.</p> <p>The first PDE is Burgers equation</p> \[\frac{\partial u(x, t)}{\partial t} + \frac{1}{2}\frac{\partial \left(u(x, t)\right)^2}{\partial x} = \nu \frac{\partial^2 u(x, t)}{\partial x^2},\] <p>with Dirichlet boundary conditions $u(0, t) = u(1, t) = 0$ and initial conditions sampled from Gaussian random field and viscosity $\nu = 0.1$.</p> <p>For Burgers equation neural networks were trained to predict $u(x, 0.3)$ from initial condition $u(x, 0)$. The examples of features and targets are on the figure below.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/Burgers_samples_II-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/Burgers_samples_II-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/Burgers_samples_II-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/Burgers_samples_II.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Samples from Burgers dataset: initial conditions $u(x, 0)$ in the first row, solution $u(x, 0.3)$ in the second row. </div> <p>The second dataset is based on stationary diffusion equation</p> \[-\frac{d}{dx}\left(k(x) \frac{d \phi(x)}{dx}\right) = 1,\,\phi(0) = \phi(1) = 0,\] <p>with $k(x)$ sampled from Gaussian random field with transformation that ensures: (i) $k(x) &gt; 0$, (ii) large spatial variability.</p> <p>The task for this equation was to predict $u(x)$ from $k(x)$. Samples from the dataset are below.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/diffusion_samples_II-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/diffusion_samples_II-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/diffusion_samples_II-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/diffusion_samples_II.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Samples from diffusion dataset: diffusivity coefficients $k(x)$ in the first row, solutions $\phi(x)$ in the second row. </div> <p>On these two datasets we train three architectures: FNO, U-Net and DeepONet with linear observations. The setup of experiment is a standard one used to demonstrate discretisation invariance <d-cite key="li2020fourier"></d-cite>:</p> <ol> <li>We generate dataset on grid with $N=512$ points.</li> <li>Neural network is trained on downsampled version with $N=64$ points.</li> <li>After training it is evaluated on grids with $64, 128, 256, 512$ points.</li> </ol> <p>The results of the experiments are reported below.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/discretisation_invariance-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/discretisation_invariance-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/discretisation_invariance-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/discretisation_invariance.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Relative test error for neural networks trained on grids with $64$ points and evaluated on grids with higher resolutions. Discretisation invariant architectures, DeepONet and FNO, show mild variations of relative error when resolution increases. In contrast, relative error of U-Net instantly reaches $&gt;100\%$ when resolution increases. </div> <p>It is quite clear that discretisation invariant architecture tolerate resolution increase much better than U-Net. Accuracy of DeepONet even slightly improves with resolution. The accuracy of FNO slowly decreases.</p> <h2 id="the-role-of-discretisation-invariance">The role of discretisation invariance</h2> <p>We have seen the definition of discretisation invariance and typical numerical demonstration that shows the difference between classical and discretisation agnostic architectures. It is not hard to find dozens of papers that develop novel discretisation agnostic architectures and confirm their discretisation invariance through experiments like the one we reproduce above. Accuracy is still important, but discretisation invariance often becomes a goal in itself. Clearly, we want to develop discretisation invariant architectures for some reason. Unfortunately, it is rarely explained <em>why</em> we need this property. We would like to invite the research community to a discussion on the purpose of discretisation invariance. Below we provide our arguments both for and against this property.</p> <h3 id="arguments-against-discretisation-invariance">Arguments against discretisation invariance</h3> <p>The main problem is a tension between infinite-dimensional setting, where discretisation invariance is relevant, and fixed resolution setting used in practice. Several manifestations of this problem are described below.</p> <p><strong>Discretisation invariance is an asymptotic property.</strong></p> <p>Both the formal definition and the typical evaluation strategies frame discretisation invariance as a statement about convergence <d-cite key="azizzadenesheli2024neural"></d-cite>. Convergence is, undeniably, crucial in classical scientific computing, as it theoretically allows one to reach arbitrary accuracy on paper and very high precision on a digital computer <d-cite key="bailey2012high"></d-cite>. However, the benefit is limited in operator learning. Test error rarely drops below certain floor (e.g., $10^{-4}$), and given that train data always has finite resolution ,it is unlikely that accuracy increases significantly beyond what was achieved during the the training stage. Indeed, in our experiments above, we did not observe a palpable increase in accuracy tied to this property. The related claim on “zero-shot superresolution” made in <d-cite key="li2020fourier"></d-cite> has similarly failed to check out in subsequent research <d-cite key="fanaskov2023spectral"></d-cite>, <d-cite key="sakarvadia2025false"></d-cite>.</p> <p><strong>Functional Data Analysis and fixed-resolution setting.</strong></p> <p>Functional Data Analysis (FDA) is a long-established field <d-cite key="ramsay1991some"></d-cite>. If FDA literature focuses on functions as objects of interest, examining classification, regression and interpolation within Banach spaces. This focus makes FDA highly related to both discretisation invariance and operator learning. Peculiarly, researchers in FDA and operator learning rarely reference each other. If we look at the modern application of machine learning, it becomes clear that the FDA is not widely popular. Some reasons for this are summarised in <a href="https://stats.stackexchange.com/a/564607" rel="external nofollow noopener" target="_blank">the illuminating discussion on StackExchange</a>. A key argument is that since all observations are finite, it is often possible to come up with an algorithm for finite data that outperforms FDA algorithms.</p> <p>Fixed resolution setting is so convenient and versatile that it is applied even when the problem has conspicuously multiresolution structure. A clear example is a deterministic weather forecast. The typical setup is a fixed-resolution training and evaluation on ERA5 dataset, where transformer-based models dominate the leaderboard <d-cite key="liu2024evaluation"></d-cite>. To be fair, discretisation invariant architectures (like FourCastNet <d-cite key="pathak2022fourcastnet"></d-cite>) are also comparable or superior to classical weather prediction models, but whether discretisation invariance itself is a key driver of their success remains unclear.</p> <p><strong>Discretisation invariance is not a good indicator of performance.</strong></p> <p>In <d-cite key="berner2025principled"></d-cite>, the authors argue that essentially any architecture can be made discretisation invariant. An interesting consequence of this finding is that discretisation invariance ceases to be a good guiding principle for architecture design. architectures perform well or poorly independently of this property, since any design can be made discretisation invariant after mild adjustments. Let’s consider FNO as a prime example.</p> <p>FNO is certainly a high-performing architecture, but why? Is its success attributable to discretisation invariance? The main component of FNO is the spectral convolution - a convolution layer parametrised in the Fourier space. In the seminal paper <d-cite key="rippel2015spectral"></d-cite> where it was introduced, the authors observed that for the fixed-resolution problem of image classification, architectures incorporating spectral convolutions and pooling converge $2$ to $5$ times faster and achieved improved accuracy compared to classical CNNs. What’s the reason? Whatever the specific driver, this performance gain was demonstrated entirely within a fixed-resolution setting and therefore operates independently of discretisation invariance.</p> <h3 id="arguments-in-favour-of-discretisation-invariance">Arguments in favour of discretisation invariance</h3> <p>Several failure modes we described above happen when one is trying to infer data at a higher resolution than was available during training. We argue that a more productive strategy is to leverage downsampling - that is, to intentionally decrease the input resolution for computational gains. Several powerful applications based on this downsampling approach are described below.</p> <p><strong>Hyperparameters optimization.</strong></p> <p>Discretisation invariance can significantly decrease the cost of grid search <d-cite key="fanaskov2025deep"></d-cite>. The strategy involves first decreasing the dataset resolution to the smallest scale the architecture allows. A regular grid search is then performed, and the $K$ configurations with highest validation accuracy are recorded. Finally, these $K$ configurations are tested again on the full resolution dataset. The authors of <d-cite key="fanaskov2025deep"></d-cite> report a reduction in grid search time by a factor of $7$, using this strategy.</p> <p><strong>Multiresolution inference.</strong></p> <p>In <d-cite key="yao2025guided"></d-cite> authors combine denoising diffusion probabilistic model with discretisation agnostic neural operator. A natural sampling approah for such a combined model is to perform most denoising steps in low resolution and then transition to high resolution only toward the end of the process. Authors report that such strategies speed up the overall process by a factor of $2$.</p> <p><strong>Pretraining and finetuning.</strong></p> <p>Neural operators can be efficiently trained on multiresolution datasets <d-cite key="li2024multi"></d-cite>. For a given parametric PDE problem, one selects a desired high resolution $N_x\times N_y$ and generates a small set of train samples. These high-resolution samples are then supplemented by a large number of low resolution samples generated on a coarse grid $n_x\times n_y$. The neural operator is initially pretrained on the large low-resolution dataset and subsequently finetuned on the small high-resolution dataset, optimizing training efficiency.</p> <h2 id="discussion">Discussion</h2> <p>We have discussed discretisation invariance from both theoretical and practical standpoints. We argue that the extrapolation from low to high resolutions is not working well in practice. A more productive direction is to select a desired resolution - a standard fixed-resolution setting pervasive in deep learning - and leverage downsampling. In our view, the benefits of discretisation invariance are not yet completely understood, and in general, this property is not fully exploited.</p> <hr> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/2026/assets/bibliography/2026-04-27-discretisation-invariance.bib"></d-bibliography> <d-article> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/fans/">FANS - Frequency-Adaptive Noise Shaping for Diffusion Models</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-reversal-curse-from-general-domain-to-remote-sensing-images/">Visual Reversal Curse: From General Domain to Remote Sensing Images</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-long-context/">Text-as-Image, A Visual Encoding Approach for Long-Context Understanding</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/vis-llm-latent-geometry/">Visualizing LLM Latent Space Geometry Through Dimensionality Reduction</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/unlearning-or-untraining/">Is your algorithm Unlearning or Untraining?</a> </li> <br> <br> </d-article> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 ICLR Blog. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/2026/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/2026/assets/js/distillpub/overrides.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/2026/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/2026/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/2026/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/2026/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/2026/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/2026/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/2026/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/2026/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/2026/assets/js/search-data.js"></script> <script src="/2026/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>