<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Discretisation invariance | ICLR Blogposts 2026 </title> <meta name="author" content="ICLR Blog"> <meta name="description" content="We are going to talk about discretisation invariance - a recent innovation in scientific machine learning. Discretisation invariance is a requirement that ensures the architecture can process inputs of different resolutions. We will formally define this property, provide examples, generate datasets, train architectures, and discuss whether discretisation invariance is living up to its promise."> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, icl# add your own keywords or leave empty"> <link rel="stylesheet" href="/2026/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/2026/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/2026/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/2026/assets/img/iclr_favicon.ico?0a8a3afdb0dbe139723b24dba3052a4f"> <link rel="stylesheet" href="/2026/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://iclr-blogposts.github.io/2026/blog/2026/discretisation-invariance/"> <script src="/2026/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/2026/assets/js/distillpub/template.v2.js"></script> <script src="/2026/assets/js/distillpub/transforms.v2.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Discretisation invariance",
            "description": "We are going to talk about discretisation invariance - a recent innovation in scientific machine learning. Discretisation invariance is a requirement that ensures the architecture can process inputs of different resolutions. We will formally define this property, provide examples, generate datasets, train architectures, and discuss whether discretisation invariance is living up to its promise.",
            "published": "April 27, 2026",
            "authors": [
              
              {
                "author": "Anonymous",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2026/"> ICLR Blogposts 2026 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2026/">home </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/about/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/call/">call for blogposts </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/submitting/">submitting </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/reviewing/">reviewing </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2026/"><strong>2026</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2025/">2025</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2024/">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2023/">2023</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blog-track.github.io/home/" rel="external nofollow noopener" target="_blank">2022</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Discretisation invariance</h1> <p>We are going to talk about discretisation invariance - a recent innovation in scientific machine learning. Discretisation invariance is a requirement that ensures the architecture can process inputs of different resolutions. We will formally define this property, provide examples, generate datasets, train architectures, and discuss whether discretisation invariance is living up to its promise.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#introduction-and-motivation">Introduction and motivation</a> </div> <div> <a href="#what-is-discretisation-invariance">What is discretisation invariance?</a> </div> <div> <a href="#examples-and-non-examples">Examples and non-examples</a> </div> <ul> <li> <a href="#fourier-neural-operator">Fourier Neural Operator</a> </li> <li> <a href="#convolutional-neural-networks">Convolutional neural networks</a> </li> <li> <a href="#deep-operator-network-with-linear-observations">Deep Operator Network with linear observations</a> </li> <li> <a href="#pca-net">PCA-Net</a> </li> <li> <a href="#neural-fields">Neural fields</a> </li> <li> <a href="#graph-neural-networks">Graph neural networks</a> </li> <li> <a href="#graph-kernel-networks">Graph kernel networks</a> </li> </ul> <div> <a href="#training-and-evaluation">Training and evaluation</a> </div> <div> <a href="#the-role-of-discretisation-invariance">The role of discretisation invariance</a> </div> </nav> </d-contents> <h2 id="introduction-and-motivation">Introduction and motivation</h2> <p>Partial differential equations (PDEs) are the gold standard in scientific modelling. With rare exceptions PDEs are solved numerically, and the goal is always to come up with a reliable, accurate algorithm that delivers a solution as cheap as possible. Neural networks were tried as a solution method starting at least from the 1990s <d-cite key="lee1990neural"></d-cite>, <d-cite key="lagaris1998artificial"></d-cite>. Over time, methods based on neural networks converged to two dominant settings: physics-informed neural networks (PINNs, <d-cite key="lagaris1998artificial"></d-cite>, <d-cite key="raissi2017physics"></d-cite>) and operator learning <d-cite key="kovachki2023neural"></d-cite>, <d-cite key="lu2021learning"></d-cite>. PINNs is an unsupervised techniques that directly aims to solve PDE. Operator learning, the approach we consider here, is a supervised technique aiming to amortize the cost of parametric PDE solution in the “multi-query setting”. We explain the setup of operator learning below.</p> <p>We start by specifying a model of interest in the form of PDE. For the sake of example we consider stationary diffusion equation</p> \[\begin{aligned} -&amp;\frac{\partial}{\partial x}\left(k(x, y)\frac{\partial}{\partial x} u(x, y)\right)-\frac{\partial}{\partial y}\left(k(x, y)\frac{\partial}{\partial y} u(x, y)\right) = f(x, y),\\ &amp;x,y\in\Gamma=(0, 1)^2,\,u(x, 0) = u(x, 1) = u(0, y) = u(1, y) = 0. \end{aligned}\] <p>This PDE naturally appears in modelling of multiphase fluid flow, heat conduction and electrostatic problems in heterogeneous media.</p> <p>PDE contains two parameters: diffusivity coefficient $k(x, y) &gt; 0$ and the source term $f(x, y)$. We assume that we need to solve the stationary diffusion equation repeatedly for a large set of parameters drawn from a joint probability distribution $k(x, y), f(x, y) \sim p_{f, k}$. One may simply call a classical solver for each new pair of parameters, but it can be more advantageous to exploit information recovered from already obtained solutions.</p> <p>This can be done in a standard regression framework: collect dataset $\left(f_1, k_1, u_1\right), \dots, \left(f_{M}, k_{M}, u_{M}\right)$, select parametric model $\mathcal{N}_{\theta}$ and train it with $L_2$ loss function</p> \[\theta^{\star} = \arg\min_{\theta}\mathbb{E}_{k, f\sim p_{k, f}}\left\|\mathcal{N}_{\theta}(k, f) - u\right\|_2^2 \simeq \arg\min_{\theta} \frac{1}{N}\sum_{i=1}^{N}\left\|\mathcal{N}_{\theta}(k_i, f_i) - u_i\right\|_2^2.\] <p>All standard techniques of machine learning apply: cross-validation, gradient descent methods, regularisation, etc.</p> <p>When PDE is discretised, continuous physical fields $k(x, y), f(x, y), u(x, y)$ become matrices, e.g., $k_{ij} = k(x_i, y_j)$ where $(x_i, y_j)$ is a point on regular grid. In this case, the regression problem is conceptually similar to classical image to image tasks: segmentation, denoising, superresolution, etc.</p> <p>Recently, a group of researchers suggested that regression problem for PDE is more than learning of image to image map <d-cite key="li2020neural"></d-cite>, <d-cite key="li2020fourier"></d-cite>. They argued that primal objects are functions themselves, not a particular way they are summarised with finite data. For example, one may represent function $k(x, y)$ on the grid with $N\times N$ points, or on the grid with $2N\times 2N$ points, or as a set of coefficients $c_{ij}$ in a finite series $k(x, y) = \sum_{i, j=1}^{N} c_{ij}\phi_{i}(x)\phi_j(y)$. Particular representations are different, but the function $k(x, y)$ remains the same in all cases. Is it possible to build a neural network that is, to a degree, agnostic to the choice of particular discretisation? The answer is positive, and the architectures with such property are now called <em>discretisation invariant</em> or <em>discretisation agnostic</em>.</p> <p>In this note we address several questions about discretisation invariance architectures:</p> <ol> <li>What is discretisation invariance? How to define it formally?</li> <li>How discretisation invariant architectures are built?</li> <li>Why is discretisation invariance important?</li> </ol> <h2 id="what-is-discretisation-invariance">What is discretisation invariance?</h2> <p>Intuitively, discretisation invariant architectures consistently map functions for different resolutions: when more details appear in the input, we expect to see more details in the output.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/waves-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/waves-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/waves-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/waves.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> An example of discretisation invariant map $\psi = \mathcal{F}(\phi)$. When input $\phi$ is available on the refined grid the output $\psi$ is refined too. </div> <p>To slightly formalise the illustration above we define sampling and interpolation operators.</p> <p>Sampling operator $\mathcal{S}_{N}:\mathcal{C}_{[0, 1]}\rightarrow \mathbb{R}^{N}$ takes function $f$ from the space of continuous functions $\mathcal{C}_{[0, 1]}$, and outputs its values on the uniform grid $x_{i} = i / (N-1),\,i=0,\dots,(N-1)$.</p> <p>Interpolation operator $\mathcal{I}_{N}:\mathbb{R}^{N}\rightarrow \mathcal{C}_{[0, 1]}$ performs an inverse operation: from a set of samples $f(x_i)$ it reconstructs function $\widetilde{f}$ by linear interpolation $\widetilde{f}(x) = \left(f(x_{i}) (x_{i+1} - x) + f(x_{i+1}) (x - x_{i})\right) / (x_{i+1} - x_{i})$ for $x \in[x_{i}, x_{i+1}]$.</p> <p>In general $f(x) \neq \mathcal{I}_{N}\left(\mathcal{S}_{N}(f)\right)(x)$ but as $N$ grows, composition $\mathcal{I}_{N}\mathcal{S}_{N}$ becomes closer to identity in the standard $L_2$ norm: $\lim\limits_{k\rightarrow\infty}\left|f - \mathcal{I}_{k}\mathcal{S}_{k} f\right|_2 = 0$.</p> <p>Having sampling $\mathcal{S}$ and interpolation $\mathcal{I}$ operators, we call map $F_{k}:\mathbb{R}^{k}\rightarrow \mathbb{R}^{k}$ discretisation invariant if sequence $\psi_k=\mathcal{I}_{k}\left(F_{k}\left(\mathcal{S}_{k}(\phi)\right)\right)$ converges to a unique element of space $\mathcal{C}_{[0, 1]}$ for each input $\phi$.</p> <p>Our definition requires several clarifications:</p> <ol> <li>We choose particular operators $\mathcal{S}_{k}$, $\mathcal{I}_{k}$ for the sake of example. In general we ask for $\mathcal{S}_{k}$ to extract finite amount of information from function, $\mathcal{I}_{k}$ to approximately restore original function from this information, and for $\mathcal{I}_{k} \mathcal{S}_{k}$ to converge to identity map.</li> <li>The operator $\mathcal{S}_{k}$ is analogous to encoder and $\mathcal{I}_{k}$ - to decoder. Unlike encoder and decoder $\mathcal{S}_{k}, \mathcal{I}_{k}$ are not learned.</li> <li>In current literature, $\mathcal{S}_{k}$ is always a sampling operator. Given that, discretisation invariance architectures are mainly architectures agnostic to the resolution of the input.</li> <li>We select $\mathcal{C}_{[0, 1]}$ space with $L_2$ norm for the sake of example. Function space and norm should be tailored to an intended application.</li> <li>When $\mathcal{S}_{k}$ and $\mathcal{I}_{k}$ are selected we can have a family of maps $F_{k}$ that always operate with finite amount of information for each $k$. Discretisation invariance is a requirement for the map $\mathcal{I}_{k}F_{k}\mathcal{R}_{k}$ to converge to a continuous operator $\mathcal{F}: \mathcal{C}_{[0, 1]} \rightarrow \mathcal{C}_{[0, 1]}$ between function spaces.</li> </ol> <p>To show that discretisation invariant operators exist, we provide a simple example from numerical analysis. Integral $G(x_i) = \int_{0}^{x_i} g(x)dx$ can be approximated with Riemann sum $G(x_i) \simeq \sum_{j=1}^{i}g(x_j)/(N-1)$. We can represent this approximation with sampling operator and linear operators $F_{k} given by $k\times k$ lower triangular matrices:</p> \[\left(F_{k}\right)_{ij} = \left\{ \begin{array}{ll} \frac{1}{k-1}, &amp; \text{if }i\leq j;\\ 0, &amp; \text{ otherwise}. \end{array} \right.\] <p>For continuous function $g$, composition of sampling, Riemann sum and interpolation $\mathcal{I}_{k}\left(F_{k}\left(\mathcal{S}_{k}g\right)\right)$ converges to antiderivative $G(x) = \int_{0}^{x}g(y)dy$.</p> <h2 id="examples-and-non-examples">Examples and non-examples</h2> <p>An example with antiderivative operator suggests a general strategy to design discretisation invariant architectures: formulate all operations on functions in continuous form and use discretisation techniques from numerical analysis to process functions consistently on grids with different resolutions <d-cite key="berner2025principled"></d-cite>, <d-cite key="li2020fourier"></d-cite>, <d-cite key="li2020neural"></d-cite>. Most discretisation invariant architectures that we describe in this section follow this general recipe.</p> <h3 id="fourier-neural-operator">Fourier Neural Operator</h3> <p>Fourier Neural Operator (FNO) is a most famous and successful example of discretisation invariant architecture <d-cite key="li2020fourier"></d-cite>. FNO is a feedforward neural network that uses three operations:</p> <ol> <li>Convolution with kernel size $1$. For input functions $v^{i}(x)$ with $N$ “channels”, the output is $\sum_{j=1}^{N}A_{ij}v^{j}(x)$.</li> <li>Pointwise nonlinear activation.</li> <li>Spectral convolution <d-cite key="rippel2015spectral"></d-cite> with truncation.</li> </ol> <p>Spectral convolution is the only operation with spatial transfer of information. It can be understood either as parametrization of convolution in the Fourier domain where convolution operator becomes diagonal <d-cite key="rippel2015spectral"></d-cite>, or as an efficient evaluation of integral operator $\int \sum_{j} s_{ij}(y - x;\theta) v^{j}(y) dy$ with particular kernel convenient for implementation. The kernel is chosen to be periodic finite bandwidth function, so the whole integral operator can be implemented in three stages:</p> <ol> <li>Fourier transform of the input with truncation $\hat{v}^{j}_{k} = \mathcal{F}(v^{j}(x))_{k},\,k=1,\dots,k_{\max}$.</li> <li>Linear operator diagonal in Fourier space $\hat{w}^{i}_{m} = \sum_{i} R_{ijm} \hat{v}^{j}_{m}$. Coefficients of tensor $R$ are learnable parameters.</li> <li>Inverse Fourier transformation with padding to restore original spatial shape $\mathcal{F}^{-1}\left(\hat{w}^{i}_{m}\right)$.</li> </ol> <p>Spectral convolution with truncation is discretisation invariant by construction, since it approximates continuous integral kernels with standard techniques from numerical analysis.</p> <p>Many other architectures follow similar design pattern, e.g., <d-cite key="tripura2022wavelet"></d-cite>, <d-cite key="gupta2021multiwavelet"></d-cite>, <d-cite key="tran2021factorized"></d-cite>, by either modifying the parametrisation of spectral convolution or replacing Fourier with other fast transformations.</p> <h3 id="convolutional-neural-networks">Convolutional neural networks</h3> <p>Architecture based on convolutional neural networks (CNNs), especially ResNet <d-cite key="he2016deep"></d-cite> and U-Net <d-cite key="ronneberger2015u"></d-cite>, are highly successful for operator learning problems <d-cite key="stachenfeld2021learned"></d-cite>, <d-cite key="raonic2023convolutional"></d-cite>. They are often applied in a form of “image-to-image” mappings, with both images being physical fields of interest computed on the uniform grids.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_conv-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_conv-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_conv-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_conv.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> For a convolution operator with kernel size $5\times5$, a regular point collects information from $5$ neighbours along each dimension (shaded area). When the grid is refined the receptive field of convolution shrinks, so each point receives data from a smaller patch of $(x, y)$ space. </div> <p>What makes convolutional architectures interesting in our context is their ability to process inputs of different resolutions. However, as illustrated in the image above, the receptive field of CNNs in coordinate space will decrease with the increase of resolution. We will see below, that when CNN is trained on fixed resolution, data on refined grid appears as out-of-distribution, leading to sharp drop in accuracy. As a result discretisation invariance is not observed.</p> <h3 id="deep-operator-network-with-linear-observations">Deep Operator Network with linear observations</h3> <p>Deep Operator Network (DeepONet) is a meta-architecture <d-cite key="lu2019deeponet"></d-cite> based on the universal approximation results for operator learning <d-cite key="chen1995universal"></d-cite>. The architecture consists of two arbitrary neural networks: branch network and trunk network. For the input function $v(x)$, the output $u(x)$ is computed as follows:</p> <ol> <li>Branch net $b$ takes whatever information about $v(x)$ is available (e.g., finite number of samples at selected points $v(x_1),\dots, v(x_d)$) and outputs a set of coefficients $c_{1}, \dots, c_{b}$.</li> <li>The final layer of trunk net $t_{1}(x),\dots,t_{b}(x)$ provides a global basis that does not depend on the input $v(x)$.</li> <li>The output of the architecture is constructed from branch and trunk nets $u(x) = \sum_{i=1}^{b} c_{i}t_{i}(x)$.</li> </ol> <p>Readers familiar with reduced order modelling may recognise that the scheme closely resembles a non-intrusive proper orthogonal decomposition.</p> <p>To make discretisation invariant DeepONet, we select a set of predefined basis function $\psi_1(x),\dots,\psi_m(x)$, and use them to form linear observations $o_i = \int \psi_{i}(x) v(x) dx$ which are later supplied to branch net. To compute linear observations, any numerical integration can be applied, e.g., <a href="https://en.wikipedia.org/wiki/Trapezoidal_rule" rel="external nofollow noopener" target="_blank">trapezoidal rule</a>.</p> <h3 id="pca-net">PCA-Net</h3> <p>PCA-Net is encoder-processor-decoder architecture based on proper-orthogonal decomposition (POD) or Karhunen–Loève expansion <d-cite key="hesthaven2018non"></d-cite>, <d-cite key="bhattacharya2021model"></d-cite>. For input $v(x)$ we compute output $u(x)$ as follows:</p> <ol> <li>Encoder finds coefficients $c = \inf_{c} \left|v(x) - \sum_{i=1}^{d} c_i\phi_i(x)\right|_2^2$, where $\phi_i(x)$ are precomputed as explained below.</li> <li>Processor is a standard feedforward architecture that transforms a vector of coefficients to another vector $d_i,i=1,\dots m$.</li> <li>Similar to DeepONet, decoder computes a linear combination $u(x) = \sum_{i=1}^{m} d_i \psi_i(x)$, where $\psi_i(x)$ are computed similarly to $\phi_i(x)$.</li> </ol> <p>For PCA-Net functions $\phi_i(x)$, $\psi_i(x)$ are computed using POD <d-cite key="volkwein2013proper"></d-cite>. Let $v_{j}(x),\,j=1,\dots,N_{\text{train}}$ be inputs from the train set. Basis functions are recursively defined as solutions to optimisation problems</p> \[\psi_i(x) = \arg \min_{\psi} \sum_{j}\left\|v_{j} - \psi\left(\psi, v_{j}\right)\right\|_{2}^{2},\text{ subject to }\left\|\psi\right\|_2 = 1,\left(\psi_{k}, \psi\right) = 0,\text{ for }k &lt; i.\] <p>That is, precisely the same way as principal components in PCA, but in functional space.</p> <h3 id="neural-fields">Neural fields</h3> <p>This is another example of encoder-processor-decoder architecture where both input and output are approximated by a form of implicit neural representation <d-cite key="serrano2023operator"></d-cite>. Operators based on neural fields work precisely as PCA-Net but uses different approach to represent functions by finite-dimensional vectors.</p> <p>To illustrate how basis functions are built, suppose we collected a dataset of inputs $v_i(x),\,i=1,\dots,N_{\text{train}}$. We select a neural network with weights $\theta$, that take coordinate $x$ in the first layer, and, in addition, vector $z$ in some hidden layer. We find parameters of the resulting architecture $\phi_{\theta}(x;z)$ by optimising the loss</p> \[\min_{\theta} \left(\sum_{i=1}^{N} \min_{z_i}\left\|\phi_{\theta}(x;z_i) - v_{i}(x)\right\|_{2}^2\right).\] <p>As a result for all dataset we will compute global parameters $\theta$ that are shared among samples $v_{i}$, and for each individual sample we find a coding vector $z_{i}$. This finite coding vector is used as a representation of function $v_i(x)$. For new inputs outside of the training set, the optimization problem above is solved with fixed $\theta$ to find finite-dimensional representation $z$. The same is done for the targets, and after that we are left with the problem of learning maps between finite dimension spaces.</p> <p>Note, that all operations in this scheme are formulated with no explicit discretisation, ensuring that the whole architecture is discretisation agnostic.</p> <h3 id="graph-neural-networks">Graph neural networks</h3> <p>Unstructured grids are very common in scientific computing, especially when complex geometries are involved. Given that, graph neural networks (GNNs) are a natural choice for building neural PDE solvers <d-cite key="brandstetter2022message"></d-cite>. GNN is an example of architecture that can handle variations in grid and geometry, but nonetheless is not discretisation invariant.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_GNN-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_GNN-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_GNN-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_GNN.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> An example of the receptive field for GNN. Similarly to CNN, receptive field shrinks when resolution is increased. </div> <p>The reason GNNs are not discretisation invariant is precisely the same as for CNNs: the architecture can be applied on a refined grid, but the receptive field is going to shrink leading to out of distribution inputs. The change in receptive field is illustrated in the picture above.</p> <h3 id="graph-kernel-networks">Graph kernel networks</h3> <p>Graph kernel network (GKN) is a discretisation agnostic version of GNN <d-cite key="li2020neural"></d-cite>. It replaces message passing by integral operator \(v_{i+1}(x, y) = \int_{B(x, y)} k_{\phi}(x, y, x^{'}, y^{'}, u(x, y), u(x^{'}, y^{'})) v_{i}(x^{'}, y^{'}) dx^{'} dy^{'},\)</p> <p>where $v_{i+1}(x, y)$ is the output of the layer, $v_{i}(x^{‘}, y^{‘})$ is an input, $B(x, y)$ is a ball of predefined radius around $x, y$, and $u(x, y)$ is an input to the network, e.g., a diffusivity coefficient in stationary diffusion equation.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_KNN-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_KNN-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_KNN-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/receptive_field_KNN.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> For graph kernel networks, the receptive field, defined in $(x, y)$ space, is a hyperparameter of the architecture. When the grid is refined a graph of nearest neighbours is recomputed, ensuring discretisation invariance of the architecture. </div> <p>A convenient way to approximate integral above is to use Monte Carlo method \(v_{i+1}(x) = \frac{1}{N_{mc}}\sum_{l=1}^{N_{mc}} k_{\phi}(x, y, x^{'}_{l}, y^{'}_{l}, u(x, y), u(x^{'}_{l}, y^{'}_{l})) v_{i}(x^{'}_{l}, y^{'}_{l}),\)</p> <p>where $(x_{l}^{‘}, y_{l}^{‘})$ are points inside a ball $B(x, y)$ as shown in the figure above.</p> <p>Importantly, the radius of the ball $B(x, y)$ is not related to discretisation used, and because of that when the grid is refined the finite sum approximates the same integral using more terms.</p> <h2 id="training-and-evaluation">Training and evaluation</h2> <p>We demonstrate discretisation invariance on three architectures and two PDEs. The code is available <a href="https://github.com/4gnskq5g2s-collab/discretisation_invariance" rel="external nofollow noopener" target="_blank">in this repository</a>. Software used include jax <d-cite key="deepmind2020jax"></d-cite> and equinox <d-cite key="kidger2021equinox"></d-cite>.</p> <p>The first PDE is Burgers equation</p> \[\frac{\partial u(x, t)}{\partial t} + \frac{1}{2}\frac{\partial \left(u(x, t)\right)^2}{\partial x} = \nu \frac{\partial^2 u(x, t)}{\partial x^2},\,u(0, t) = u(1, t) = 0,\] <p>with initial conditions sampled from Gaussian random field and viscosity $\nu = 0.1$.</p> <p>For Burgers equation neural networks were trained to predict $u(x, 0.3)$ from initial condition $u(x, 0)$. The examples of features and targets are on the figure below.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/Burgers_samples-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/Burgers_samples-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/Burgers_samples-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/Burgers_samples.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Samples from Burgers dataset: initial conditions $u(x, 0)$ in the first row, solution $u(x, 0.3)$ in the second row. </div> <p>The second dataset is based on stationary diffusion equation</p> \[-\frac{d}{dx}\left(k(x) \frac{d \phi(x)}{dx}\right) = 0,\,\phi(0) = \phi(1) = 0,\] <p>with $k(x)$ sampled from Gaussian random field with transformation that ensures: (i) $k(x) &gt; 0$, (ii) large spatial variability.</p> <p>The task for this equation was to predict $u(x)$ from $k(x)$. Samples from the dataset are below.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/diffusion_samples-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/diffusion_samples-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/diffusion_samples-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/diffusion_samples.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Samples from diffusion dataset: diffusivity coefficients $k(x)$ in the first row, solutions $\phi(x)$ in the second row. </div> <p>On these two datasets we train three architectures: FNO, U-Net and DeepONet with linear observations. The setup of experiment is a standard one used to demonstrate discretisation invariance <d-cite key="li2020fourier"></d-cite>:</p> <ol> <li>We generate dataset on grid with $N=512$ points.</li> <li>Neural network is trained on downsampled version with $N=64$ points.</li> <li>After training it is evaluated on grids with $64, 128, 256, 512$ points.</li> </ol> <p>The results of the experiments are reported below.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-discretisation-invariance/discretisation_invariance-480.webp 480w,/2026/assets/img/2026-04-27-discretisation-invariance/discretisation_invariance-800.webp 800w,/2026/assets/img/2026-04-27-discretisation-invariance/discretisation_invariance-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-discretisation-invariance/discretisation_invariance.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Relative test error for neural networks trained on grids with $64$ points and evaluated on grids with higher resolutions. Discretisation invariant architectures, DeepONet and FNO, show mild variations of relative error when resolution increases. In contrast, relative error of U-Net instantly reaches $&gt;100\%$ when resolution increases. </div> <p>It is quite clear that discretisation invariant architecture tolerate resolution increase much better than U-Net. Accuracy of DeepONet even slightly improves with resolution. The accuracy of FNO slowly decreases.</p> <h2 id="the-role-of-discretisation-invariance">The role of discretisation invariance</h2> <p>We have seen the definition of discretisation invariance and typical numerical demonstration that shows the difference between classical and discretisation agnostic architectures. It is not hard to find dozens of papers that develop novel discretisation invariant architectures and confirm it by experiments alike one we reproduce above. The accuracy is still important, but discretisation invariance becomes a goal in itself. Clearly, for some reason we want to develop discretisation invariant architectures. Unfortunately, it is rarely explained <em>why</em> we need this. We would like to invite research community to a discussion on the end of discretisation invariance. We provide arguments against discretisation invariance and hope that other researchers will publish arguments for discretisation invariance elsewhere.</p> <p><strong>Discretisation invariance is an asymptotic property.</strong></p> <p>From the definition, and from typical evaluation strategy, discretisation invariance is a statement about convergence <d-cite key="azizzadenesheli2024neural"></d-cite>. Convergence is important in scientific computing, because it allows one to reach arbitrary accuracy on paper and very high precision on digital computer <d-cite key="bailey2012high"></d-cite>. In contrast, for operator learning problem error rarely drops below $10^{-4}$, and given that train data has finite resolution it is unlikely that accuracy increases beyond what was reached on the training stage.</p> <p><strong>Functional data analysis. All data is finite-dimensional.</strong></p> <p>Functional data analysis (FDA) is there for quite some time <d-cite key="ramsay1991some"></d-cite>. If we look at the literature on FDA, we find that the objects of interest are functions, and researchers in FDA study classification, regression and interpolation in Banach spaces. Given that, FDA is very related to operator learning and discretisation invariance, albeit researchers in these two fields rarely reference each other. Peculiarly enough, FDA is not popular in the modern applications of machine learning. Some reasons for that are summarised in <a href="https://stats.stackexchange.com/a/564607" rel="external nofollow noopener" target="_blank">the illuminating discussion</a> on StackExchange. One argument is all the observations we have are finite, and it is often possible to come up with an algorithm for finite data that outperforms FDA algorithms.</p> <p><strong>Discretisation invariance is not a good indicator of performance.</strong></p> <p>In <d-cite key="berner2025principled"></d-cite> authors argue that essentially any architecture can be made discretisation invariant. An interesting consequence of this claim is discretisation invariance ceases to be a good guiding principle for architecture design. Some architecture perform well, some perform poorly, but discretisation invariance has nothing to do with that, since any architecture is discretisation invariant after mild adjustments. Lets consider FNO as an example.</p> <p>FNO is certainly a great architecture, but why? Is it because of discretisation invariance? The main component of FNO is spectral convolution, i.e., a convolution layer parametrised in the Fourier space. In the paper <d-cite key="rippel2015spectral"></d-cite>, where it was introduced, authors observed that for image classification problem (problem with fixed resolution) architectures with spectral convolutions and pooling converge $2$ to $5$ times faster and lead to improved accuracy in comparison with classical CNNs. Why is that? Whatever the answer is, it unlikely invokes discretisation invariance.</p> <p><strong>When trained on grid with fixed resolution, classical architectures often perform better.</strong></p> <p>As we already discussed in the section on FDA, methods specialised for finite-dimensional data are often perform better. An apt example is deterministic weather forecast where transformer-based models are at the top of the leaderboard <d-cite key="liu2024evaluation"></d-cite>. To be fair, discretisation invariant architectures are also comparable or superior to classical weather prediction models <d-cite key="pathak2022fourcastnet"></d-cite>, but whether discretisation invariance has a role in its success is unclear.</p> <p><strong>Use cases for discretisation invariance are slim.</strong></p> <p>A popular neural operator library <a href="https://neuraloperator.github.io/dev/theory_guide/advantages.html" rel="external nofollow noopener" target="_blank">list many advantages of the approach</a>. Some of them are clearly misleading, e.g., “The approximation quality improves as the input resolution increases, with the error vanishing in the limit of infinite resolution.” This is not what is observed, in practice approximation quality deteriorates with resolution or, at best, saturates. Some are overly optimistic “Once trained, neural operators can produce high-resolution solutions much faster than traditional numerical methods, often achieving speedups of 100-1,000,000x!” See <d-cite key="mcgreivy2024weak"></d-cite> for the impartial evaluation of neural PDE solvers. Importantly, authors of the library do not provide any references supporting their claims.</p> <p>A central motif of many stated advantages is the benefit of processing data with different resolutions consistently. In particular, authors suggest that one can train neural operator on low resolution data and finetune on high resolution data. We believe this statement is accurate and it should be possible to speed up training that way. This is the only use case of discretisation invariance we can come up with.</p> <hr> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/2026/assets/bibliography/2026-04-27-discretisation-invariance.bib"></d-bibliography> <d-article> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/fans/">FANS - Frequency-Adaptive Noise Shaping for Diffusion Models</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-reversal-curse-from-general-domain-to-remote-sensing-images/">Visual Reversal Curse: From General Domain to Remote Sensing Images</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-long-context/">Text-as-Image, A Visual Encoding Approach for Long-Context Understanding</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/vis-llm-latent-geometry/">Visualizing LLM Latent Space Geometry Through Dimensionality Reduction</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/using-large-language-models-to-simulate-and-predict-human-decision-making/">Using Large Language Models to Simulate and Predict Human Decision-Making</a> </li> <br> <br> </d-article> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 ICLR Blog. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/2026/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/2026/assets/js/distillpub/overrides.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/2026/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/2026/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/2026/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/2026/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/2026/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/2026/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/2026/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/2026/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/2026/assets/js/search-data.js"></script> <script src="/2026/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>