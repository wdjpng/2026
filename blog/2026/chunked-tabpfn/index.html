<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> ChunkTabPFN: Training-free Long Context | ICLR Blogposts 2026 </title> <meta name="author" content="ICLR Blog"> <meta name="description" content="Tabular foundation models struggle with large datasets due to the quadratic attention. While methods like FlashAttention promise scalability, practical challenges persist in their application to tabular foundation models. Our work resolves these hurdles, enabling efficient attention, and reveals that contrary to the eariler reports, TabPFN's performance improves with larger contexts, highlighting its inherent robustness and minimal fine-tuning needs when scaling to complex, long datasets from the TabArena benchmark."> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, icl# add your own keywords or leave empty"> <link rel="stylesheet" href="/2026/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/2026/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/2026/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/2026/assets/img/iclr_favicon.ico?0a8a3afdb0dbe139723b24dba3052a4f"> <link rel="stylesheet" href="/2026/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://iclr-blogposts.github.io/2026/blog/2026/chunked-tabpfn/"> <script src="/2026/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/2026/assets/js/distillpub/template.v2.js"></script> <script src="/2026/assets/js/distillpub/transforms.v2.js"></script> <style type="text/css">.inline-math{font-family:var(--sans-serif);font-weight:500;background:rgba(0,0,0,0.03);padding:0 .25em;border-radius:.25em}.attn-figure-caption{font-size:.9rem;color:rgba(0,0,0,0.6);margin-top:.5rem;text-align:center}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "ChunkTabPFN: Training-free Long Context",
            "description": "Tabular foundation models struggle with large datasets due to the quadratic attention. While methods like FlashAttention promise scalability, practical challenges persist in their application to tabular foundation models. Our work resolves these hurdles, enabling efficient attention, and reveals that contrary to the eariler reports, TabPFN's performance improves with larger contexts, highlighting its inherent robustness and minimal fine-tuning needs when scaling to complex, long datasets from the TabArena benchmark.",
            "published": "April 27, 2026",
            "authors": [
              
              {
                "author": "Anonymous",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2026/"> ICLR Blogposts 2026 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2026/">home </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/about/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/call/">call for blogposts </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/submitting/">submitting </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/reviewing/">reviewing </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2026/"><strong>2026</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2025/">2025</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2024/">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2023/">2023</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blog-track.github.io/home/" rel="external nofollow noopener" target="_blank">2022</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>ChunkTabPFN: Training-free Long Context</h1> <p>Tabular foundation models struggle with large datasets due to the quadratic attention. While methods like FlashAttention promise scalability, practical challenges persist in their application to tabular foundation models. Our work resolves these hurdles, enabling efficient attention, and reveals that contrary to the eariler reports, TabPFN's performance improves with larger contexts, highlighting its inherent robustness and minimal fine-tuning needs when scaling to complex, long datasets from the TabArena benchmark.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#1-introduction">1. Introduction</a> </div> <div> <a href="#2-methodology">2. Methodology</a> </div> <div> <a href="#3-experiments">3. Experiments</a> </div> <div> <a href="#4-conclusion">4. Conclusion</a> </div> </nav> </d-contents> <h2 id="1-introduction">1. Introduction</h2> <p><span id="sec:introduction"></span></p> <p>Large language models leverage <strong>in-context learning (ICL)</strong> by adapting their predictions at inference time based solely on provided examples, without requiring any gradient updates. Building on this idea, recent work on <strong>tabular foundation models</strong>, such as TabPFN, TabICL, Mitra, and Limix, extends the same paradigm to tabular data <d-cite key="hollmann2022tabpfn,hollmann2025accurate,qu2025tabicl,zhang2025mitra,zhang2025limix"></d-cite>. These models are trained once on synthetic tasks drawn from a prior, allowing them to approximate the posterior predictive distribution</p> \[p(y_{*} \mid x_*, D_{\text{train}})\] <p>in a single forward pass by supplying the training set as context, without any dataset-specific fine-tuning, without fine-tuning on each new dataset <d-cite key="hollmann2022tabpfn,hollmann2025accurate"></d-cite>. This approach is compelling because it contrasts with most deep tabular models—like TabNet, FT-Transformer, NODE, TabM, or retrieval-style models such as TabR and ModernNCA, which typically require dataset-specific training or fine-tuning <d-cite key="arik2021tabnet,gorishniy2021revisiting,popov2019neural,gorishniy2024tabm,gorishniy2023tabr,ye2024modern"></d-cite>. That dependency undermines the ideal of a true “drop-in foundation model.”</p> <p>ICL-based tabular models move closer to this ideal. However, they face a major practical limitation: <strong>context length</strong>. Transformer attention scales quadratically with sequence length, and current public TabPFN implementations are constrained to around 3,000 samples in the original work to 10,000<d-footnote>At the time of writing, the new TabPFN v2.5 model has just been released, which is supposed to have pushed the context limit further to 50,000.</d-footnote> in later versions <d-cite key="hollmann2022tabpfn,hollmann2025accurate"></d-cite>. Many real-world tabular datasets far exceed these limits.</p> <p>To address this, researchers have experimented with <strong>shrinking the context</strong>, such as by clustering, partitioning, or retrieving only subsets of the data. Examples include random-forest partitioning <d-cite key="hollmann2025accurate"></d-cite>, the Mixture of In-Context Prompters (MICP) <d-cite key="xu2024mixture"></d-cite>, and KNN-style retrieval <d-cite key="thomas2024retrieval"></d-cite>. Others, like TuneTables <d-cite key="feuer2024tunetables"></d-cite>, compress the data into learned representations.</p> <p>While these methods can be effective, they come with two drawbacks:</p> <ul> <li>They often require <strong>dataset-specific tuning</strong> or even retraining, which contradicts the zero-shot, pure ICL philosophy.</li> <li>They don’t use the <strong>entire training set</strong>, which is a core assumption of TabPFN’s Bayesian approximation. Replacing full data with summaries introduces conceptual inaccuracy.</li> </ul> <p>Hence, we ask the following question:</p> <blockquote> <p>Can we fit <strong>all training examples</strong> into the context (no pruning, no KNN) without learnable compression while staying within GPU memory?</p> </blockquote> <p>In this work, we focus specifically on TabPFN, though we believe the conclusions extend to other ICL-based tabular models. Our answer is a resounding <strong>yes</strong>. Indeed, TabPFN’s native implementation already supports this on some devices via <strong>FlashAttention</strong> <d-cite key="dao2022flashattention,dao2023flashattention,shah2024flashattention"></d-cite>. But as we’ll show in this blogpost, there are important caveats:</p> <ul> <li>FlashAttention and similar efficient mechanisms can <strong>fail</strong> when batch or head sizes exceed 65,535.</li> <li>These optimizations are <strong>unsupported</strong> on older or consumer-grade GPUs.</li> </ul> <p>To resolve this, we introduce a <strong>simple patch</strong>:</p> <ul> <li>For efficient attention, we <strong>chunk inputs</strong> along head or batch dimensions to avoid hitting the 65,536 limit.</li> <li>For older GPUs, we implement a <strong>chunked forward pass</strong> in pure PyTorch using the <strong>incremental log-sum-exp trick</strong>.</li> </ul> <p>This patch yields results <strong>identical to standard attention</strong> (up to floating-point associativity), without any approximations, fine-tuning, or pre-filtering.</p> <p>Empirically, we then test TabPFN out-of-the-box scalability by evaluating it on the full <strong>TabArena</strong> benchmark <d-cite key="tabarena"></d-cite>. We specifically analyze TabPFN performance on datasets with <strong>long contexts</strong> (&gt; 10,000). Key findings include:</p> <ul> <li> <strong>Accuracy improves</strong> with more data, often up to 100,000+ rows (measured in AUC for classification and RMSE for regression).</li> <li>On smaller contexts (&lt;10,000), our chunked version <strong>matches the original</strong>—no hidden degradation.</li> <li>The runtime stays <strong>practical</strong> even on commodity GPUs.</li> </ul> <h2 id="2-methodology">2. Methodology</h2> <p><span id="sec:methodology"></span></p> <p>Let <code class="language-plaintext highlighter-rouge">(X, y)</code> be the input to the TabPFN model. The typical dimensions of the feature tensor are <code class="language-plaintext highlighter-rouge">[B, L, F]</code>, where <code class="language-plaintext highlighter-rouge">B</code> is the number of datasets in the batch, <code class="language-plaintext highlighter-rouge">L</code> is the (padded) sample size, and <code class="language-plaintext highlighter-rouge">F</code> is the number of features. The first thing TabPFN does is group features <code class="language-plaintext highlighter-rouge">X</code> and embed them, which yields the following shape: <code class="language-plaintext highlighter-rouge">[B, L, G, D]</code>, where <code class="language-plaintext highlighter-rouge">G</code> is the number of feature groups and <code class="language-plaintext highlighter-rouge">D</code> is the embedding size. In the rest of the blog, we assume <code class="language-plaintext highlighter-rouge">X</code> already has this post-embedding shape.</p> <p>The labels <code class="language-plaintext highlighter-rouge">y</code> are similarly embedded and then concatenated with the features along the group dimension, producing an input of shape <code class="language-plaintext highlighter-rouge">[B, L, G + 1, D]</code>. A keen reader might notice that <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">X</code> effectively have different “logical” lengths: <code class="language-plaintext highlighter-rouge">X</code> includes both train and test samples, while <code class="language-plaintext highlighter-rouge">y</code> is only provided for the training split. This is handled by padding the label embeddings for test samples with a dummy embedding. A variable <code class="language-plaintext highlighter-rouge">single_eval_pos</code> in the original code holds the index where train and test samples are concatenated, and this logic can be seen in the <code class="language-plaintext highlighter-rouge">transformer.py</code> file of the original TabPFN repository.</p> <p>The core of TabPFN is the attention mechanism, whose logic is primarily implemented in <code class="language-plaintext highlighter-rouge">layer.py</code>. TabPFN, like many Transformer-style models, uses attention in two ways: <strong>between samples</strong> and <strong>between features</strong>. The between-sample attention has both self- and cross-attention components: self-attention among training samples and cross-attention from test samples to train samples. Following the TabPFN implementation, we assume attention layers expect input of shape <code class="language-plaintext highlighter-rouge">[batch, seq_len, input_size]</code>. In the code, the leading dimensions before <code class="language-plaintext highlighter-rouge">(seq_len, input_size)</code> are collapsed via <code class="language-plaintext highlighter-rouge">_rearrange_inputs_to_flat_batch</code>. For between-feature attention this yields an effective batch size of <code class="language-plaintext highlighter-rouge">L * B</code>, whereas for between-item (between-sample) attention it yields <code class="language-plaintext highlighter-rouge">(G + 1) * B</code>.</p> <p>Recall that efficient attention implementations in PyTorch (such as the fused CUDA kernels backing <code class="language-plaintext highlighter-rouge">torch.nn.functional.scaled_dot_product_attention</code>) tile work across the <strong>batch</strong> and <strong>head</strong> dimensions. On NVIDIA GPUs of Ampere architecture and below, this effectively limits the product <code class="language-plaintext highlighter-rouge">B * num_heads</code> to at most <code class="language-plaintext highlighter-rouge">65535</code> CUDA blocks; when it reaches <code class="language-plaintext highlighter-rouge">65536</code> the kernel can fail with <code class="language-plaintext highlighter-rouge">CUDA error: invalid configuration argument</code> (see the corresponding <a href="https://github.com/pytorch/pytorch/issues/133976" rel="external nofollow noopener" target="_blank">PyTorch GitHub issue</a> for a minimal example where <code class="language-plaintext highlighter-rouge">65535</code> works but <code class="language-plaintext highlighter-rouge">65536</code> fails). In TabPFN, large sample sizes <code class="language-plaintext highlighter-rouge">L</code> or a large number of feature groups <code class="language-plaintext highlighter-rouge">G</code> can easily push these flattened batch sizes (<code class="language-plaintext highlighter-rouge">L * B</code> or <code class="language-plaintext highlighter-rouge">(G + 1) * B</code>) past this limit.</p> <p>A simple practical fix is to loop over the flattened batch dimension in chunks, so that each call to <code class="language-plaintext highlighter-rouge">scaled_dot_product_attention</code> stays within the kernel’s limits. This keeps the rest of the model unchanged while avoiding the <code class="language-plaintext highlighter-rouge">invalid configuration</code> errors at large <code class="language-plaintext highlighter-rouge">L</code> or <code class="language-plaintext highlighter-rouge">G</code>. Conceptually, this is can be done via the following patch to the attention computation.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">q_chunk</span><span class="p">,</span> <span class="n">k_chunk</span><span class="p">,</span> <span class="n">v_chunk</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span>
    <span class="n">torch</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">torch</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">k_b</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">torch</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">v_b</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
<span class="p">):</span>
    <span class="c1"># (B_chunk, Lq, H, D) -&gt; (B_chunk, H, Lq, D)
</span>    <span class="n">Q</span> <span class="o">=</span> <span class="n">q_chunk</span><span class="p">.</span><span class="nf">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nf">contiguous</span><span class="p">()</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">k_chunk</span><span class="p">.</span><span class="nf">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nf">contiguous</span><span class="p">()</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">v_chunk</span><span class="p">.</span><span class="nf">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nf">contiguous</span><span class="p">()</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">scaled_dot_product_attention</span><span class="p">(</span>
        <span class="n">Q</span><span class="p">,</span>
        <span class="n">K</span><span class="p">,</span>
        <span class="n">V</span><span class="p">,</span>
        <span class="n">attn_mask</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">dropout_p</span><span class="o">=</span><span class="n">dropout_p</span> <span class="k">if</span> <span class="n">dropout_p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">is_causal</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">softmax_scale</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># (B_chunk, H, Lq, D)
</span>
    <span class="c1"># -&gt; (B_chunk, Lq, H, D)
</span>    <span class="n">outputs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="nf">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nf">contiguous</span><span class="p">())</span>

<span class="n">attention_head_outputs</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div> <p>A different issue is <strong>hardware support</strong> for efficient attention kernels. PyTorch’s <code class="language-plaintext highlighter-rouge">scaled_dot_product_attention</code> can dispatch to several backends on CUDA: FlashAttention, memory-efficient attention, or a plain math implementation in C++. The availability of these specialized kernels varies across GPU generations. For educational purposes, and for those who wish to implement these kernels on older or unsupported devices, we refer to <a href="https://github.com/lucidrains/memory-efficient-attention-pytorch/tree/main" rel="external nofollow noopener" target="_blank">this repository</a>. We provide a brief sketch of how the chunking works to reduce the memory footprint below.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">chunked_attention</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">q_chunk</span><span class="p">,</span> <span class="n">kv_chunk</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    q: (..., Lq, D)
    k: (..., Lk, D)
    v: (..., Lk, Dv)
    q_chunk: size of query tiles (l)
    kv_chunk: size of key/value tiles (r)
    </span><span class="sh">"""</span>
    <span class="n">Lq</span><span class="p">,</span> <span class="n">Lk</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="n">k</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">qs</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Lq</span><span class="p">,</span> <span class="n">q_chunk</span><span class="p">):</span>
        <span class="n">qe</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">qs</span> <span class="o">+</span> <span class="n">q_chunk</span><span class="p">,</span> <span class="n">Lq</span><span class="p">)</span>
        <span class="n">q_tile</span> <span class="o">=</span> <span class="n">q</span><span class="p">[...,</span> <span class="n">qs</span><span class="p">:</span><span class="n">qe</span><span class="p">,</span> <span class="p">:]</span>                            <span class="c1"># (..., l, D)
</span>
        <span class="c1"># running stats per query row
</span>        <span class="n">mu</span> <span class="o">=</span> <span class="n">q_tile</span><span class="p">.</span><span class="nf">new_full</span><span class="p">(</span><span class="n">q_tile</span><span class="p">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="nf">float</span><span class="p">(</span><span class="sh">"</span><span class="s">inf</span><span class="sh">"</span><span class="p">))</span>  <span class="c1"># (..., l)
</span>        <span class="n">s</span>  <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>                               <span class="c1"># (..., l)
</span>        <span class="n">a</span>  <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="o">*</span><span class="n">mu</span><span class="p">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                         <span class="n">device</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">dtype</span><span class="p">)</span>        <span class="c1"># (..., l, Dv)
</span>
        <span class="k">for</span> <span class="n">ks</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Lk</span><span class="p">,</span> <span class="n">kv_chunk</span><span class="p">):</span>
            <span class="n">ke</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">ks</span> <span class="o">+</span> <span class="n">kv_chunk</span><span class="p">,</span> <span class="n">Lk</span><span class="p">)</span>
            <span class="n">k_tile</span> <span class="o">=</span> <span class="n">k</span><span class="p">[...,</span> <span class="n">ks</span><span class="p">:</span><span class="n">ke</span><span class="p">,</span> <span class="p">:]</span>                           <span class="c1"># (..., r, D)
</span>            <span class="n">v_tile</span> <span class="o">=</span> <span class="n">v</span><span class="p">[...,</span> <span class="n">ks</span><span class="p">:</span><span class="n">ke</span><span class="p">,</span> <span class="p">:]</span>                           <span class="c1"># (..., r, Dv)
</span>
            <span class="n">logits</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">q_tile</span><span class="p">,</span> <span class="n">k_tile</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">scale</span>
            <span class="n">local_max</span> <span class="o">=</span> <span class="n">logits</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>               <span class="c1"># (..., l)
</span>            <span class="n">new_mu</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">local_max</span><span class="p">)</span>

            <span class="c1"># rescale old aggregates
</span>            <span class="n">alpha</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">mu</span> <span class="o">-</span> <span class="n">new_mu</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">*=</span> <span class="n">alpha</span>
            <span class="n">a</span> <span class="o">*=</span> <span class="n">alpha</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span>

            <span class="c1"># accumulate current tile
</span>            <span class="n">exp_logits</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">logits</span> <span class="o">-</span> <span class="n">new_mu</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">])</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">exp_logits</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>                         <span class="c1"># sum_k e^{z_k}
</span>            <span class="n">a</span> <span class="o">+=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matmul</span><span class="p">(</span><span class="n">exp_logits</span><span class="p">,</span> <span class="n">v_tile</span><span class="p">)</span>               <span class="c1"># sum_k e^{z_k} v_k
</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">new_mu</span>

        <span class="n">outputs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">s</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">])</span>                        <span class="c1"># softmax = a / s
</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>                           <span class="c1"># (..., Lq, Dv)
</span></code></pre></div></div> <p>In this implementation, the key components are:</p> <ul> <li>It tiles queries into chunks <code class="language-plaintext highlighter-rouge">q_chunk</code> instead of processing all <code class="language-plaintext highlighter-rouge">Lq</code> at once.</li> <li>It streams over keys/values in chunks <code class="language-plaintext highlighter-rouge">kv_chunk</code>, computing only <code class="language-plaintext highlighter-rouge">l × r</code> logits at a time.</li> <li>It maintains per-row running statistics <code class="language-plaintext highlighter-rouge">(mu, s, a)</code> using a numerically stable log-sum-exp merge, so the final output matches full attention as if we had formed the entire <code class="language-plaintext highlighter-rouge">Lq × Lk</code> score matrix in one go.</li> </ul> <h2 id="3-experiments">3. Experiments</h2> <p><span id="sec:experiments"></span></p> <p>We evaluate the TabPFN v2 model with chunking enabled on <strong>TabArena</strong> <d-cite key="tabarena"></d-cite>, which includes 51 tabular datasets spanning classification and regression tasks. We report scaling statistics for memory and runtime in Figure 1, and overall performance on TabArena in Figure 2. Note that in the original and subsequent reports of TabPFN, LIMIX, and TabICL on TabArena, the authors have typically imputed values that exceeded the context length for their respective methods. This might have created a distorted view of model capabilities. In Figure 2, we use only directly measured (non-imputed) results.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-chunked-tabpfn/tabarena_long_results-480.webp 480w,/2026/assets/img/2026-04-27-chunked-tabpfn/tabarena_long_results-800.webp 800w,/2026/assets/img/2026-04-27-chunked-tabpfn/tabarena_long_results-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-chunked-tabpfn/tabarena_long_results.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="attn-figure-caption"> Figure 1. Scaling TabPFN v2 to long contexts. Chunked TabPFN matches baseline accuracy where both fit, and extends inference to 100K+ examples. </div> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-chunked-tabpfn/elo_vs_baselines-480.webp 480w,/2026/assets/img/2026-04-27-chunked-tabpfn/elo_vs_baselines-800.webp 800w,/2026/assets/img/2026-04-27-chunked-tabpfn/elo_vs_baselines-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-chunked-tabpfn/elo_vs_baselines.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="attn-figure-caption"> Figure 2. Elo and normalized score across TabArena. Striped bars denote prior imputed TabPFN runs (filled with Random Forest fallbacks when OOM); our chunked TabPFN reports direct measurements. </div> <p>Separately, we evaluate TabPFN v2 on the same long-context datasets while varying the context length. Specifically, we sample <code class="language-plaintext highlighter-rouge">num_samples</code> points from each dataset and then report performance, memory, and runtime in Figure 3. To better understand how context length affects TabPFN’s performance, we perform a <em>scaling study</em> on the 15 “long-context” datasets from TabArena. For each dataset, we subsample the training set to progressively larger sizes (3,000 → 5,000 → 10,000 → 20,000 → 50,000 → 100,000) and compare baseline TabPFN v2 against our Chunked TabPFN.</p> <ul> <li>Chunked TabPFN maintains <em>exact equivalence</em> to baseline TabPFN while extending feasible context length by roughly 10×.</li> <li>Empirical scaling shows either plateau or monotonic improvement—never catastrophic degradation.</li> <li>Memory and runtime growth are linear in chunk size, enabling inference on 100 K+ examples with a single GPU.</li> </ul> <p>These findings reinforce that <strong>TabPFN’s in-context generalization truly extends beyond its training limit</strong>, and that the primary bottleneck was <em>implementation-level memory</em>, not <em>model-level capacity</em>.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-chunked-tabpfn/tabarena_long_results_per_dataset-480.webp 480w,/2026/assets/img/2026-04-27-chunked-tabpfn/tabarena_long_results_per_dataset-800.webp 800w,/2026/assets/img/2026-04-27-chunked-tabpfn/tabarena_long_results_per_dataset-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-chunked-tabpfn/tabarena_long_results_per_dataset.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="attn-figure-caption"> Figure 4. Scaling curves for long-context datasets. Each plot shows RMSE, AUC, wall-clock inference time (s), and peak GPU memory (MB). Chunked TabPFN tracks baseline accuracy exactly up to 10 K examples and continues scaling to 100 K without degradation. </div> <h2 id="4-conclusion">4. Conclusion</h2> <p><span id="sec:conclusion"></span></p> <p>We presented <strong>Chunked TabPFN</strong>, an exact tiling strategy that enables TabPFN to process <em>long-context</em> tabular datasets (100 K+ rows) without retraining, fine-tuning, or any pre-processing such as clustering or compression.</p> <p>Our main results show:</p> <ol> <li> <p><strong>Exactness without approximation.</strong> The chunked attention computation is mathematically identical to the original transformer attention—only the evaluation order changes. Predictions match baseline TabPFN bit-for-bit (within floating-point tolerance) for all short-context cases.</p> </li> <li> <p><strong>Memory scalability.</strong> Peak GPU memory scales linearly with tile size instead of quadratically with context length. This removes the practical 10 K-sample ceiling and allows inference on 100 K+ rows using 24–32 GB GPUs.</p> </li> <li> <p><strong>Training-free generalization.</strong> Chunked TabPFN retains the spirit of in-context learning: no dataset-specific training, no hyperparameter search, no adaptation steps. Despite its simplicity, it matches or surpasses tuned deep tabular models on the long-context slice of TabArena.</p> </li> <li> <p><strong>Empirical insights.</strong> Many datasets continue to improve with larger contexts—suggesting that the PFN prior generalizes beyond its nominal pre-training length.</p> </li> </ol> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/2026/assets/bibliography/2026-04-27-chunked-tabpfn.bib"></d-bibliography> <d-article> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/wait-do-we-need-to-wait/">Wait, Do We Need to Wait? Revisiting Budget Forcing for Sequential Test-Time Scaling</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/symbolic-connect/">Symbolism Outside, Connectionism Inside: The Trend of Fusing LLMs and Automatic Programs with Symbolic Intermediate Representations</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/sac-massive-sim/">Getting SAC to Work on a Massive Parallel Simulator: An RL Journey With Off-Policy Algorithms</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/nlp-for-human-sciences/">Language as a Window Into the Mind: How NLP and LLMs Advance Human Sciences</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/model-misspecification-in-sbi/">Model Misspecification in Simulation-Based Inference - Recent Advances and Open Challenges</a> </li> <br> <br> </d-article> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 ICLR Blog. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/2026/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/2026/assets/js/distillpub/overrides.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/2026/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/2026/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/2026/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/2026/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/2026/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/2026/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/2026/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/2026/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/2026/assets/js/search-data.js"></script> <script src="/2026/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>