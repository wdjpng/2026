<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> The 99% Success Paradox: When Near-Perfect Retrieval Equals Random Selection | ICLR Blogposts 2026 </title> <meta name="author" content="ICLR Blog"> <meta name="description" content="For most of the history of information retrieval (IR), search results were designed for human consumers who could scan, filter, and discard irrelevant information on their own. This shaped retrieval systems to optimize for finding and ranking more relevant documents, but not keeping results clean and minimal, as the human was the final filter. However, LLMs have changed that by lacking this filtering ability. To address this, we introduce Bits-over-Random (BoR), a chance-corrected measure of retrieval selectivity that reveals when high success rates mask random-level performance."> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, icl# add your own keywords or leave empty"> <link rel="stylesheet" href="/2026/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/2026/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/2026/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/2026/assets/img/iclr_favicon.ico?0a8a3afdb0dbe139723b24dba3052a4f"> <link rel="stylesheet" href="/2026/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://iclr-blogposts.github.io/2026/blog/2026/bits-over-random/"> <script src="/2026/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/2026/assets/js/distillpub/template.v2.js"></script> <script src="/2026/assets/js/distillpub/transforms.v2.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "The 99% Success Paradox: When Near-Perfect Retrieval Equals Random Selection",
            "description": "For most of the history of information retrieval (IR), search results were designed for human consumers who could scan, filter, and discard irrelevant information on their own. This shaped retrieval systems to optimize for finding and ranking more relevant documents, but not keeping results clean and minimal, as the human was the final filter. However, LLMs have changed that by lacking this filtering ability. To address this, we introduce Bits-over-Random (BoR), a chance-corrected measure of retrieval selectivity that reveals when high success rates mask random-level performance.",
            "published": "April 27, 2026",
            "authors": [
              
              {
                "author": "Anonymous",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2026/"> ICLR Blogposts 2026 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2026/">home </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/about/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/call/">call for blogposts </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/submitting/">submitting </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/reviewing/">reviewing </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2026/"><strong>2026</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2025/">2025</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2024/">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2023/">2023</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blog-track.github.io/home/" rel="external nofollow noopener" target="_blank">2022</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>The 99% Success Paradox: When Near-Perfect Retrieval Equals Random Selection</h1> <p>For most of the history of information retrieval (IR), search results were designed for human consumers who could scan, filter, and discard irrelevant information on their own. This shaped retrieval systems to optimize for finding and ranking more relevant documents, but not keeping results clean and minimal, as the human was the final filter. However, LLMs have changed that by lacking this filtering ability. To address this, we introduce Bits-over-Random (BoR), a chance-corrected measure of retrieval selectivity that reveals when high success rates mask random-level performance.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#introduction">Introduction</a> </div> <div> <a href="#the-million-token-trap">The Million-Token Trap</a> </div> <div> <a href="#what-traditional-metrics-miss">What Traditional Metrics Miss</a> </div> <div> <a href="#the-librarian-problem">The Librarian Problem</a> </div> <div> <a href="#the-new-baseline-random-chance">The New Baseline: Random Chance</a> </div> <div> <a href="#the-math">The Math</a> </div> <div> <a href="#a-concrete-example">A Concrete Example</a> </div> <div> <a href="#the-ceiling-problem">The Ceiling Problem</a> </div> <div> <a href="#bor-optimistic-upper-bound">BoR optimistic upper bound</a> </div> <div> <a href="#the-collapse-zone">The Collapse Zone</a> </div> <div> <a href="#what-happens-when-you-retrieve-more">What Happens When You Retrieve More?</a> </div> <div> <a href="#the-doubling-rule">The Doubling Rule</a> </div> <div> <a href="#case-studies-when-theory-meets-reality">Case Studies: When Theory Meets Reality</a> </div> <div> <a href="#when-perfect-success-fails">When Perfect Success Fails</a> </div> <div> <a href="#ai-agent-tool-selection">AI Agent Tool Selection</a> </div> <div> <a href="#what-you-should-do-about-this">What You Should Do About This</a> </div> <div> <a href="#sidebar-successk-vs-recallk">Sidebar: SuccessK vs RecallK</a> </div> <div> <a href="#final-thoughts">Final Thoughts</a> </div> </nav> </d-contents> <h2 id="introduction">Introduction</h2> <p>For most of the history of information retrieval (IR), search results were designed for human consumers who could scan, filter, and discard irrelevant content on their own. This shaped retrieval systems to optimize for finding and ranking more relevant documents, but not for keeping results clean and minimal, as the human was the final filter.</p> <p><strong>Retrieval-augmented generation (RAG)</strong> and tool-using agents flip these assumptions. Now the consumer is often an LLM, not a person, and the model does not skim. In practice, introducing excessive or irrelevant context into the input can dilute the model’s ability to identify and focus on the most critical information. When you pass retrieved documents to an LLM:</p> <ul> <li>It can’t ignore irrelevant results. Every irrelevant chunk dilutes the model’s attention.</li> <li>Noise has a cost. Extra chunks cost tokens, latency, and computation. They also increase the odds that irrelevant or misleading content pulls attention away from what actually matters.</li> </ul> <h2 id="the-million-token-trap">The Million-Token Trap</h2> <p>You might be thinking: <em>“But modern LLMs have million-token context windows. Why care?”</em></p> <p>The real question isn’t whether a model can fit more context, but whether more context is actually helpful. Beyond a certain point, adding retrieved material (and the accompanying noise) can actively increase computational cost and degrade the quality of output.</p> <p>In our 20 Newsgroups classification case study, we increased the retrieval depth <strong>K</strong> from 10 to 100 items. This caused LLM accuracy to drop from 66% to 50%, even though the success metric (<strong>Success@K:</strong> the percentage of queries returning at least one relevant item) remained close to 100%. In other words, more retrieved content led to worse results, not better.</p> <p>This problem is especially severe for agentic systems that use tool-based retrieval, because context quality directly affects downstream decisions. A chatbot might give you a mediocre answer, however, an autonomous agent might call the wrong API, delete the wrong file, or execute the wrong command.</p> <p>We need a measure that asks: <em>“Given that I’m retrieving K items and my LLM will consume all of them, how much <strong>selective signal</strong> am I actually getting?”</em></p> <p>That’s what Bits-over-Random (BoR) measures. The rest of this post explains how.</p> <h2 id="what-traditional-metrics-miss">What Traditional Metrics Miss</h2> <p>Recall rewards finding more relevant documents, but is blind to how many irrelevant items you had to pull into the context window to get them. Over-retrieval is actually rewarded. As Manning et al.<d-cite key="manning2008introduction"></d-cite> note, “recall is a non-decreasing function of the number of documents retrieved”. Yet the choice of retrieval depth K is often an empirical, application-dependent choice <d-cite key="webber2010similarity"></d-cite>.</p> <p>Precision measures the relevance of retrieved results and helps limit excessive retrieval. However, it fails to account for the inherent difficulty of the retrieval task. For instance, achieving a 10% precision means something different if the corpus contains 10 relevant items out of 100 versus 10 relevant items out of 10,000. Same precision, very different selectivity.</p> <p>Ranking metrics (nDCG, RBP, MAP, ERR) penalize burying relevant items, but they do not penalize the presence of irrelevant items when the relevant item is also ranked highly. If you retrieve 100 items and the relevant one is at rank 1, nDCG can be perfect. Yet, RAG systems typically concatenate the top-K results into a single prompt. The LLM still has to read the other 99 items. Rankers optimize ordering, not volume. They don’t reduce the token cost of stuffing <strong>K</strong> documents into the context.</p> <p>In practice, teams end up juggling recall, precision, and ranking metrics. Each captures a different slice of behavior but none reflects the whole picture. There is no single framework that simultaneously accounts for how many items you retrieve, how big the corpus is, and how many items in the corpus are actually relevant to the query.</p> <h2 id="the-librarian-problem">The Librarian Problem</h2> <p>Consider a library of \(N = 1{,}000\) books, with \(R_q = 10\) books relevant to your query. Two librarians respond:</p> <ul> <li> <strong>Librarian A</strong> retrieves \(K = 20\) books, 6 of which are relevant (precision 30%, recall 60%, F1 40%).</li> <li> <strong>Librarian B</strong> retrieves \(K = 12\) books, 4 of which are relevant (precision 33%, recall 40%, F1 36%).</li> </ul> <p>Traditional IR metrics tend to favor Librarian A (higher recall and F1, similar precision). But Librarian A handed you 14 irrelevant books, versus B’s 8. If the librarians are retrievers or tools in an agent workflow and the consumer is an LLM, it must read everything it was given. Those 6 extra unhelpful books retrieved by Librarian A over Librarian B cost tokens, add noise, and waste computational resources.</p> <h2 id="the-new-baseline-random-chance">The New Baseline: Random Chance</h2> <p>And here’s the deeper question: <em>Beyond comparing A and B, is either of them an objectively skillful librarian? What is the baseline?</em></p> <p>If we compare each librarian to a random baseline (<em>“what if I picked K books uniformly at random?”</em>), we can ask which one is actually more selective than chance. Plugging these numbers into the chance-corrected formulas we introduce below shows that Librarian B is more selective than A. For an LLM consuming a fixed-size bundle of text, that selectivity per token is what matters.</p> <p>This is the key insight: every retrieval problem has a built-in baseline. If you picked <strong>K</strong> items completely at random, you’d still sometimes get lucky and grab something relevant, especially if relevant items are common.</p> <p>That random success rate is your floor. It tells you how much of your <em>“success”</em> is just dumb luck. Bits-over-Random (BoR) measures how far above random success you’ve climbed.</p> <p>In today’s RAG, agentic, and LLM workflows, we care less about who retrieved the most documents and more about who delivered the most signal with the least noise. By comparing a chosen success metric to random chance, BoR measures true selectivity: how much better is our retrieval bundle than random selection?</p> <p>Let’s break down how it works, step by step.</p> <h2 id="the-math">The Math</h2> <p>Evaluating a retriever shouldn’t require juggling incompatible metrics. To make sense of how well a system is actually performing, we need a baseline. Not just any baseline, but the most honest one possible: pure randomness. The framework below walks through a simple, quantitative way to express <em>“how much better than random”</em> your retrieval system really is.</p> <p>By measuring observed success, computing the expected success of random guessing, and comparing the two on a logarithmic scale, we end up with a clean, intuitive metric: <strong>Bits-over-Random (BoR)</strong>. This gives retrieval performance a natural, information-theoretic interpretation, each bit representing one doubling in effectiveness over chance.</p> <h2 id="the-quick-reference-version">The Quick-Reference Version</h2> <p>Here’s everything you need to remember:</p> <table> <thead> <tr> <th style="text-align: left">Symbol</th> <th style="text-align: left">Meaning</th> <th style="text-align: left">Example</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">\(N\)</td> <td style="text-align: left">Total items in corpus. Unit must be defined (e.g., documents, passages)</td> <td style="text-align: left">10,000 passages or 700 documents</td> </tr> <tr> <td style="text-align: left">\(K\)</td> <td style="text-align: left">How many items you retrieve per query (top-K)</td> <td style="text-align: left">\(K=10\) or \(K=100\)</td> </tr> <tr> <td style="text-align: left">\(R_q\)</td> <td style="text-align: left">Relevant items in the corpus for a certain query q</td> <td style="text-align: left">\(R_q=1\) (sparse) or \(R_q=20\) (many)</td> </tr> <tr> <td style="text-align: left">\(\bar{R}_q\)</td> <td style="text-align: left">Average relevant items in the corpus per query</td> <td style="text-align: left">≈1.1 on SciFact, ≈572 on 20 Newsgroups</td> </tr> <tr> <td style="text-align: left">\(P_{obs}(K)\)</td> <td style="text-align: left">Your observed success rate at K (Note: any success rate can be used here.)</td> <td style="text-align: left">60% of queries succeed</td> </tr> <tr> <td style="text-align: left">\(P_{rand}(K)\)</td> <td style="text-align: left">Random-chance success at K</td> <td style="text-align: left">What luck would give you</td> </tr> <tr> <td style="text-align: left">\(\lambda\)</td> <td style="text-align: left">Heuristic: expected random hits = \(K \cdot \bar{R}_q / N\)</td> <td style="text-align: left">\(\lambda\) in the 3–5 range signals collapse</td> </tr> </tbody> </table> <h3 id="step-1-measure-your-success-rate">Step 1. Measure Your Success Rate</h3> <p>First, pick a success condition. For most RAG systems, the natural rule is: <em>“Did I get at least one relevant item in my top-K results?”</em></p> <p>This is called <strong>Success@K</strong> (or coverage). For a batch of queries:</p> \[P_{\text{obs}}(K) = \frac{\text{number of queries with } \geq \text{ 1 relevant result in top-}K}{\text{total queries}}\] <p><strong>Note:</strong> The threshold doesn’t have to be 1. You can require at least m relevant documents if your system needs multiple pieces of evidence, for example, “at least 3 supporting passages.”</p> <p>If you retrieved K=10 items for 100 queries, and 60 queries got at least one relevant hit, then \(P_{\text{obs}}(10) = 60 / 100 = 0.60\).</p> <h3 id="step-2-calculate-the-random-baseline">Step 2. Calculate the Random Baseline</h3> <p>What if you picked <strong>K</strong> items completely at random? That’s your baseline.</p> <p>For a query where \(R_q\) items in the corpus are relevant, and the corpus has <strong>N</strong> total items, the hypergeometric distribution tells you the probability of randomly hitting at least one relevant item when picking <strong>K</strong> items:</p> <p>The probability of picking no relevant items in <strong>K</strong> picks is:</p> \[P_{\text{none}} = \frac{\binom{N-R_q}{K}}{\binom{N}{K}}\] <p>So, the probability of picking at least one relevant item is:</p> \[P_{\text{rand}} = 1 - P_{\text{none}} = 1 - \frac{\binom{N-R_q}{K}}{\binom{N}{K}}\] <p><strong>Special case:</strong> If every query has exactly one relevant item (\(R_q = 1\)), this simplifies to:</p> \[P_{\text{rand}}(K) = \frac{K}{N}\] <p>For example:</p> <table> <thead> <tr> <th>Parameter</th> <th>Value</th> </tr> </thead> <tbody> <tr> <td>\(N\)</td> <td>10,000</td> </tr> <tr> <td>\(R_q\)</td> <td>10</td> </tr> <tr> <td>\(K\)</td> <td>20</td> </tr> </tbody> </table> \[P_{\text{rand}} = 1 - \frac{\binom{9990}{20}}{\binom{10000}{20}} \approx 0.02\] <p>This means random selection works <strong>~2%</strong> of the time.</p> <p>Because we evaluate over many queries, we average these random baselines:</p> \[\overline{P}_{\text{rand}}(K) = \text{average random success across all queries}\] \[\overline{P}_{\text{rand}}(K) = \frac{1}{|Q|} \sum\nolimits_{q} P_{\text{rand}}(K; R_q)\] <h3 id="step-3-enrichment-factor-how-many-times-are-we-better-than-random-chance">Step 3: Enrichment factor: how many times are we better than random chance?</h3> <p><strong>Enrichment Factor (EF)</strong> is defined as</p> \[\text{EF} = \frac{P_{\text{obs}}}{P_{\text{rand}}}\] <p>For a batch of queries, we use the averaged random baseline:</p> \[\text{EF}(K) = \frac{P_{\text{obs}}(K)}{\overline{P}_{\text{rand}}(K)}\] <p>An EF of 5 means you succeed 5× more often than random selection. An EF of 100 means you are 100× better. This formulation is consistent with enrichment metrics used in drug discovery screening <d-cite key="truchon2007evaluating"></d-cite>.</p> <h3 id="step-4-bits-over-random-bor-log-scale-conversion-of-ef">Step 4: Bits-over-Random (BoR): Log Scale conversion of EF</h3> \[\text{BoR} = \log_2(\text{EF}) = \log_2\left(\frac{P_{\text{obs}}}{P_{\text{rand}}}\right)\] <p>And similarly for averaging:</p> \[\text{BoR}(K) = \log_2(\text{EF}) = \log_2\left(\frac{P_{\text{obs}}(K)}{\overline{P}_{\text{rand}}(K)}\right)\] <p>Why \(\log_2\)? Bits are how information theory counts halvings, the same reason why binary search uses powers of 2. Each bit represents one halving of the search space. <strong>BoR = 10</strong> means <strong>10 halvings → 1,024× reduction</strong>.</p> <ul> <li> <strong>BoR = 0</strong> → You’re no better than random</li> <li> <strong>BoR = 1</strong> → <strong>2×</strong> better than random</li> <li> <strong>BoR = 3</strong> → <strong>8×</strong> better than random</li> <li> <strong>BoR = 10</strong> → <strong>1,024×</strong> better than random</li> </ul> <p>Each bit also represents a doubling of selectivity. Our definition follows.</p> <p><strong>Selectivity (n.):</strong> The ability of a retrieval system to surface relevant items while excluding irrelevant ones, measured relative to random chance. A system with high selectivity finds needles without bringing along the haystack.</p> <h2 id="a-concrete-example">A Concrete Example</h2> <p>Let’s assume you have 10,000 documents. Each query has exactly ten relevant documents (\(R_q = 1\)). <strong>Note:</strong> Many standard benchmarks such as MS MARCO have \(R_q ≈ 1\) on average, even sparser than this example.</p> <p>You are testing two different retriever systems against the same dataset:</p> <table> <thead> <tr> <th>Metric</th> <th>System A (K=20, 60% success)</th> <th>System B (K=100, 70% success)</th> </tr> </thead> <tbody> <tr> <td>P_obs</td> <td>0.60</td> <td>0.70</td> </tr> <tr> <td>P_rand</td> <td>0.01983</td> <td>0.09566</td> </tr> <tr> <td>EF (Enrichment Factor)</td> <td>0.60/0.01983 = 30.257</td> <td>0.70/0.09566 = 7.318</td> </tr> <tr> <td>BoR</td> <td>4.92 bits</td> <td>2.87 bits</td> </tr> </tbody> </table> <p><strong>System B</strong> has a higher raw success rate (70% vs. 60%) but a BoR score about 2 bits lower than <strong>System A</strong>. This lower score shows <strong>System B</strong> is less selective. It achieves higher coverage by expanding the retrieved set, which reduces informational efficiency. From an information-theoretic view, System B creates a larger <em>“haystack”</em> that delivers fewer useful bits of discrimination per query.</p> <h2 id="the-ceiling-problem">The Ceiling Problem</h2> <p>There’s a maximum BoR you can possibly achieve. If your system is perfect, achieving \(P_{\text{obs}}(K) = 1.0\) (every single query succeeds), the best you can do is:</p> \[\text{BoR}_{\text{max}}(K) = -\log_2(\overline{P}_{\text{rand}}(K))\] <p>This ceiling is determined entirely by the random baseline. Using our toy example:</p> <ul> <li> <strong>System A:</strong> \(\text{BoR}_{\text{max}} = -\log_2(0.01983) = 5.66\) bits</li> <li> <strong>System B:</strong> \(\text{BoR}_{\text{max}} = -\log_2(0.09566) = 3.39\) bits</li> </ul> <p>System A, even at 60% success, achieves 4.92 bits, already higher than System B’s ceiling. No amount of model improvement can help System B catch up. Given its success rate, it chose a retrieval depth K that limits its maximum possible selectivity.</p> <p><strong>When the random baseline is already high, even perfection gets you almost nothing.</strong></p> <h2 id="bor-optimistic-upper-bound">BoR optimistic upper bound</h2> <p>When you don’t know how many relevant items \(R_q\) exist in the corpus for each query, BoR enables you to define an optimistic upper bound by assuming each query has exactly one relevant item. In that case:</p> \[P_{\text{rand}}(K) \approx \frac{K}{N}\] <p>And:</p> \[\text{BoR}_{\text{opt}}(K) = \log_2\left(\frac{N}{K}\right)\] <p>It’s useful to compute the upper bound if calculating exact BoR is not feasible. \(\text{BoR}_{\text{opt}}(K)\) is an optimistic ceiling: no system on that corpus at depth <strong>K</strong> can have more than about \(\log_2(N / K)\) bits of selectivity under this assumption.</p> <p>Note that \(\text{BoR}_{\text{max}}\) uses actual \(R_q\) values while \(\text{BoR}_{\text{opt}}\) assumes \(R_q = 1\) throughout.</p> <h2 id="the-collapse-zone">The Collapse Zone</h2> <iframe src="/2026/assets/html/2026-04-27-bits-over-random/calculator.html" frameborder="0" scrolling="no" height="580px" width="100%" class="l-body rounded z-depth-1"></iframe> <p>Consider what happens when retrieval becomes <strong>“too easy”</strong>:</p> <ul> <li>If \(P_{\text{rand}} = 0.95\) (random selection succeeds 95% of the time), then even a perfect system only gets \(\text{BoR}_{\text{max}} \approx 0.07\) bits</li> <li>If \(P_{\text{rand}} = 0.99\) (random succeeds 99% of the time), then \(\text{BoR}_{\text{max}} \approx 0.01\) bits</li> </ul> <p>We call this the <em>“collapse zone.”</em> When you enter it, selectivity becomes mathematically impossible, even if your success rate looks great.</p> <p>The boundary is determined by:</p> \[\lambda = \frac{K \cdot \bar{R}_q}{N}\] <p>Where \(\bar{R}_q\) is the average number of relevant items per query.</p> <p>When \(\lambda\) reaches 3–5, you’ve entered the collapse zone. Random selection is already solving most queries, so even a perfect system can’t demonstrate meaningful skill.</p> <h2 id="what-happens-when-you-retrieve-more">What Happens When You Retrieve More?</h2> <p>Now that we have formulated a measure that evaluates an IR system with respect to random selection at a given K, what happens when you increase K (K₁ to K₂)? Typically, we expect the following:</p> <ol> <li>Your success rate improves (usually)</li> <li>Random selection also gets easier (always)</li> </ol> <p>The change in BoR is:</p> \[\Delta\text{BoR} = \log_2\left(\frac{P_2}{P_1}\right) - \log_2\left(\frac{\overline{P}_{\text{rand}}(K_2)}{\overline{P}_{\text{rand}}(K_1)}\right)\] <p>Translation:</p> <ul> <li> <strong>First term:</strong> <em>“How much better did I actually do?”</em> </li> <li> <strong>Second term:</strong> <em>“How much easier did the task get for random guessing?”</em> </li> </ul> <h2 id="the-doubling-rule">The Doubling Rule</h2> <p>In typical sparse-relevance scenarios (\(R_q \ll N\) and \(K \ll N\)), the hypergeometric baseline behaves like repeated independent draws. For small values of \(K \cdot R_q / N\), we can use standard approximations \((1 - x)^n \approx e^{-nx}\) and \(e^{-y} \approx 1 - y\) for \(y \to 0\).</p> <p>So, because: \(P_{\text{rand}}(K; R_q) \approx \frac{K \cdot R_q}{N}\) and averaging over queries yields \(\overline{P}_{\text{rand}}(K) \approx \frac{K \cdot \bar{R}_q}{N}\)</p> <p>We now have:</p> \[\Delta\text{BoR} \approx \log_2\left(\frac{P_2}{P_1}\right) - \log_2\left(\frac{K_2}{K_1}\right)\] <p>What does this mean in practice?</p> <p><strong>If you double K, but your success rate doesn’t improve, you lose about 1 bit of selectivity.</strong></p> <p>When you hear <strong>“just retrieve more,”</strong> remember: it’s not free. Once your success rate has plateaued:</p> <ul> <li>Double <strong>K</strong> and you lose \(\sim 1\) bit of selectivity</li> <li>\(10\times\) <strong>K</strong> and you lose \(\sim 3.3\) bits of selectivity</li> </ul> <p>To maintain selectivity when doubling <strong>K</strong>, you’d need \(P_{\text{obs}}\) to also double. But since \(P_{\text{obs}} \leq 1\), this becomes impossible once you’re above 50% success.</p> <p><strong>That’s why BoR inevitably degrades at larger depths once your success curve flattens.</strong></p> <h3 id="extensions-to-stricter-rules">Extensions to Stricter Rules</h3> <p>The BoR framework extends to stricter success rules. For example, requiring at least <strong>m</strong> relevant documents in the top-K:</p> \[\Delta\text{BoR} \approx -m \cdot \log_2\left(\frac{K_2}{K_1}\right)\] <p>Doubling K costs about <strong>m bits</strong> of selectivity. We focus on \(m=1\) in this post because it matches common single-evidence RAG scenarios.</p> <h2 id="case-studies-when-theory-meets-reality">Case Studies: When Theory Meets Reality</h2> <p>Let’s see how BoR behaves in the wild. We tested three different scenarios:</p> <table> <thead> <tr> <th style="text-align: left">Dataset</th> <th style="text-align: left">Corpus Size</th> <th style="text-align: left">Relevant Items per Query</th> <th style="text-align: left">Why Test It?</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>BEIR SciFact</strong></td> <td style="text-align: left">5,183 abstracts (1,409 queries/claims)</td> <td style="text-align: left">Sparse (\(R_q \approx 1\)–2)</td> <td style="text-align: left">Baseline: typical RAG scenario</td> </tr> <tr> <td style="text-align: left"><strong>MS MARCO</strong></td> <td style="text-align: left">~8.8M passages</td> <td style="text-align: left">Sparse (\(R_q \approx 1\))</td> <td style="text-align: left">Large scale: does BoR work at production size?</td> </tr> <tr> <td style="text-align: left"><strong>20 Newsgroups</strong></td> <td style="text-align: left">11,314 docs (training set) class-based setup</td> <td style="text-align: left">Dense (\(\bar{R}_q \approx 572\))</td> <td style="text-align: left">Stress test: what happens when selectivity collapses?</td> </tr> </tbody> </table> <p>We tested two retrievers representing different eras and approaches.</p> <ul> <li> <strong>BM25:</strong> The classic lexical baseline</li> <li> <strong>SPLADE:</strong> Modern neural sparse retriever (<a href="https://huggingface.co/naver/splade-cocondenser-ensembledistil" rel="external nofollow noopener" target="_blank">naver/splade-cocondenser-ensembledistil</a>): document top-k = 60, query top-k = 60, max sequence length = 256, batch size = 64 for documents and queries</li> </ul> <p>All results use exact hypergeometric baselines and 95% confidence intervals from bootstrap resampling (n=5,000, seed=7).</p> <h3 id="test-1-scifact-the-benchmark-case">Test 1: SciFact (The Benchmark Case)</h3> <p>This is what most people expect: sparse relevance, the kind you see in real RAG systems.</p> <p><strong>The results:</strong></p> <p>Both systems maintain strong selectivity even at <strong>K=100</strong>, with BoR staying above 5 bits. Predicted ΔBoR values match observed changes to within <strong>0.01</strong> bits across all configurations.</p> <p>This confirms that when \(\lambda = \frac{K \cdot \bar{R}_q}{N} \ll 1\) (well outside the collapse zone), retrieval systems can demonstrate meaningful selectivity over random chance.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-bits-over-random/boR_analysis_scifact-480.webp 480w,/2026/assets/img/2026-04-27-bits-over-random/boR_analysis_scifact-800.webp 800w,/2026/assets/img/2026-04-27-bits-over-random/boR_analysis_scifact-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-bits-over-random/boR_analysis_scifact.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>Figure 1:</strong> <em>BoR analysis on the SciFact dataset shows sustained selectivity across retrieval depths. Both BM25 and SPLADE maintain high BoR values (5–11 bits), reflecting the dataset’s sparse relevance structure.</em></p> <p>But both BM25 and SPLADE operate very close to the theoretical ceiling. A 30-year-old algorithm nearly matches the modern neural system.</p> <p>Is SciFact just too easy? To investigate, we turn to literature and examine a much larger benchmark. On a corpus with millions of passages, how much headroom exists between top-performing systems and the theoretical ceiling?</p> <h3 id="test-2-ms-marco-the-industrial-scale-test">Test 2: MS MARCO (The Industrial Scale Test)</h3> <p>8.84 million passages. This is where large real-world systems operate.</p> <p>We computed BoR for <strong>41 different systems</strong> from the literature, from lexical baselines to state-of-the-art neural retrievers.</p> <p>At <strong>K=1000</strong>, the theoretical ceiling is:</p> \[\text{BoR}_{\text{opt}} \approx \log_2\left(\frac{8.84\text{M}}{1000}\right) \approx 13.11 \text{ bits}\] <p><strong>All 41 systems cluster within 0.2 bits of this ceiling.</strong> Indicatively, to show the range:</p> <table> <thead> <tr> <th style="text-align: left">System</th> <th style="text-align: left">Recall@1000</th> <th style="text-align: left">BoR (bits)</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">BM25</td> <td style="text-align: left">85.7%</td> <td style="text-align: left">12.89</td> </tr> <tr> <td style="text-align: left">SPLADE</td> <td style="text-align: left">97.9%</td> <td style="text-align: left">13.08</td> </tr> <tr> <td style="text-align: left">ColBERTv2</td> <td style="text-align: left">98.5%</td> <td style="text-align: left">13.09</td> </tr> <tr> <td style="text-align: left">SimLM</td> <td style="text-align: left">98.7%</td> <td style="text-align: left">13.09</td> </tr> </tbody> </table> <p>BM25 gets 85.7% recall. SimLM (state-of-the-art) gets 98.7% recall. That’s a <strong>13-point recall gap.</strong></p> <p>But the BoR difference? <strong>Only 0.20 bits.</strong></p> <p>A three-decade-old lexical algorithm and cutting-edge neural systems are very close in chance-corrected selectivity (BoR) at this depth, for this dataset, and success rule (in this case, recall). This suggests diminishing returns from retriever improvements alone.</p> <p>Systems examined include: SimLM, AR2, uniCOIL, ColBERTv2, SPLADE (multiple versions), I3 Retriever, TCT-ColBERTv2, RoDR w/ ANCE, DPR-CLS, ColBERTer, ANCE, SLIM/SLIM++, and BM25.</p> <p>But both still show meaningful selectivity: BoR is above 12 bits. To really see what collapse looks like, we need an extreme test: a dataset where relevance is abundant, not rare.</p> <h3 id="test-3-20-newsgroups-the-stress-test">Test 3: 20 Newsgroups (The Stress Test)</h3> <p>The 20 Newsgroups dataset has 20 topical categories. We set up an extreme scenario: treat all documents in the same category as “relevant.”</p> <p>With <strong>11,314</strong> documents split across <strong>20</strong> classes, that’s about \(\bar{R}_q \approx 572\) relevant documents per query (over <strong>5%</strong> of the corpus).</p> <p>Why test something so unrealistic? Because, as you’ll see later, this can happen in LLM agent tool selection.</p> <p>This scenario pushes us directly into the collapse zone. At <strong>K = 100</strong>:</p> \[\lambda = \frac{K \cdot \bar{R}_q}{N} = \frac{100 \times 572}{11{,}314} \approx 5.1\] <p>Random selection alone would succeed ~99% of the time. The ceiling for any retrieval system is essentially zero. To make the contrast as clear as possible, here is 20NG vs SciFact against both systems.</p> <p><strong>Watch what happens:</strong></p> <table> <thead> <tr> <th style="text-align: left">Dataset</th> <th style="text-align: left">K</th> <th style="text-align: left">BoR Ceiling</th> <th style="text-align: left">BM25 Success</th> <th style="text-align: left">BM25 BoR</th> <th style="text-align: left">SPLADE Success</th> <th style="text-align: left">SPLADE BoR</th> <th style="text-align: left">ΔBoR (10→100)</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>20NG</strong></td> <td style="text-align: left">10</td> <td style="text-align: left">1.31 bits</td> <td style="text-align: left">94%</td> <td style="text-align: left">1.22</td> <td style="text-align: left">95%</td> <td style="text-align: left">1.23</td> <td style="text-align: left">−1.22</td> </tr> <tr> <td style="text-align: left"><strong>20NG</strong></td> <td style="text-align: left">100</td> <td style="text-align: left">0.01 bits</td> <td style="text-align: left">100%</td> <td style="text-align: left">0.01</td> <td style="text-align: left">100%</td> <td style="text-align: left">0.01</td> <td style="text-align: left">—</td> </tr> <tr> <td style="text-align: left"><em>SciFact</em></td> <td style="text-align: left">10</td> <td style="text-align: left">8.84 bits</td> <td style="text-align: left">80%</td> <td style="text-align: left">8.52</td> <td style="text-align: left">81%</td> <td style="text-align: left">8.53</td> <td style="text-align: left">−3.12</td> </tr> <tr> <td style="text-align: left"><em>SciFact</em></td> <td style="text-align: left">100</td> <td style="text-align: left">5.52 bits</td> <td style="text-align: left">89%</td> <td style="text-align: left">5.36</td> <td style="text-align: left">93%</td> <td style="text-align: left">5.41</td> <td style="text-align: left">—</td> </tr> </tbody> </table> <p>At K=100 on 20 Newsgroups:</p> <ul> <li>Both systems achieve <strong>100% success</strong> </li> <li>Both provide <strong>0.01 bits of selectivity</strong> </li> </ul> <p>Perfect success rate. Essentially zero selectivity. <strong>The ceiling has collapsed.</strong></p> <p>The predicted <strong>ΔBoR</strong> from theory matches reality within <strong>0.01</strong> bits. The math is working exactly as expected.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-bits-over-random/selectivity_collapse_paradox_newsgroups-480.webp 480w,/2026/assets/img/2026-04-27-bits-over-random/selectivity_collapse_paradox_newsgroups-800.webp 800w,/2026/assets/img/2026-04-27-bits-over-random/selectivity_collapse_paradox_newsgroups-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-bits-over-random/selectivity_collapse_paradox_newsgroups.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>Figure 2:</strong> <em>The selectivity collapse paradox on 20 Newsgroups. Left: BoR declines sharply with depth, converging to the theoretical ceiling (dashed line). Right: As Success@K approaches 100%, BoR approaches zero.</em></p> <p>But here’s the real question: <strong>Does this theoretical collapse actually hurt downstream performance?</strong></p> <h2 id="when-perfect-success-fails">When Perfect Success Fails</h2> <p>We tested this directly with a modern instruction-tuned LLM on the 20 Newsgroups collapsed scenario.</p> <p>Setup: Multiple-choice classification task, 50 queries per configuration, temperature=0.0.</p> <p><strong>The results:</strong></p> <table> <thead> <tr> <th style="text-align: left">System</th> <th style="text-align: left">Accuracy at K=10</th> <th style="text-align: left">Accuracy at K=100</th> <th style="text-align: left">Success@K</th> <th style="text-align: left">Token Cost</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>BM25</strong></td> <td style="text-align: left">66%</td> <td style="text-align: left"><strong>50%</strong></td> <td style="text-align: left">94% → 100%</td> <td style="text-align: left">10x increase</td> </tr> <tr> <td style="text-align: left"><strong>SPLADE</strong></td> <td style="text-align: left">68%</td> <td style="text-align: left"><strong>58%</strong></td> <td style="text-align: left">95% → 100%</td> <td style="text-align: left">10x increase</td> </tr> </tbody> </table> <p>Read that again:</p> <ul> <li>Success rate increased to 100% ✓</li> <li>Accuracy <strong>dropped</strong> by 10–16 percentage points ✗</li> <li>Token cost increased 10x ✗</li> </ul> <p><strong>This is the failure mode BoR detects.</strong> You’re paying 10x the tokens for random-level selectivity, and your AI is drowning in noise.</p> <p>When selectivity collapses, high success rates become meaningless or worse, misleading.</p> <h2 id="ai-agent-tool-selection">AI Agent Tool Selection</h2> <p>“That 20 Newsgroups test seems artificial,” you might be thinking. “Who retrieves documents where 5% of the corpus is relevant?”</p> <p>Fair Point. Let’s extend our testing to what happens with AI agents everyday.</p> <h3 id="when-agents-choose-tools">When Agents Choose Tools</h3> <p>Consider what Anthropic published in 2025<d-cite key="anthropic2025toolselection"></d-cite>:</p> <p><em>“Tool definitions can sometimes consume 50,000+ tokens before an agent reads a request. Agents should discover and load tools on-demand, keeping only what’s relevant for the current task.”</em></p> <p>Their example: 58 tools consuming ~55K tokens. Add integrations like Jira and you’re at 100K+ tokens. They’ve seen setups with tool definitions consuming 134K tokens before optimization.</p> <p>Now, let’s apply the same math as document retrieval:</p> <table> <thead> <tr> <th style="text-align: left">Parameter</th> <th style="text-align: left">Document Retrieval</th> <th style="text-align: left">Tool Selection</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>N</strong></td> <td style="text-align: left">Corpus size (thousands to millions)</td> <td style="text-align: left">Available tools (50–500)</td> </tr> <tr> <td style="text-align: left"><strong>K</strong></td> <td style="text-align: left">Documents shown to LLM</td> <td style="text-align: left">Tools shown to LLM</td> </tr> <tr> <td style="text-align: left"><strong>\(R_q\)</strong></td> <td style="text-align: left">Relevant documents</td> <td style="text-align: left">Applicable tools for task</td> </tr> </tbody> </table> <p>The critical difference: <strong>N is small for tools.</strong> And small N means you hit the collapse boundary much faster.</p> <h3 id="the-tool-selection-collapse">The Tool Selection Collapse</h3> <p>Let’s run the numbers for Anthropic’s 58-tool example. Assume 3–5 tools are typically relevant:</p> <table> <thead> <tr> <th style="text-align: left">Configuration</th> <th style="text-align: left">K</th> <th style="text-align: left">\(R_q\)</th> <th style="text-align: left">\(\lambda = \frac{K \cdot R_q}{N}\)</th> <th style="text-align: left">\(\text{BoR}_{\text{max}}\) (Poisson)</th> <th style="text-align: left">\(\text{BoR}_{\text{max}}\) (Exact)</th> <th style="text-align: left">What This Means</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">Show 5 tools</td> <td style="text-align: left">5</td> <td style="text-align: left">4</td> <td style="text-align: left">0.34</td> <td style="text-align: left">~1.6 bits</td> <td style="text-align: left">~1.7</td> <td style="text-align: left">Meaningful selectivity</td> </tr> <tr> <td style="text-align: left">Show 20 tools</td> <td style="text-align: left">20</td> <td style="text-align: left">4</td> <td style="text-align: left">1.38</td> <td style="text-align: left">~0.4 bits</td> <td style="text-align: left">0.28</td> <td style="text-align: left">Degraded</td> </tr> <tr> <td style="text-align: left">Show all 58</td> <td style="text-align: left">58</td> <td style="text-align: left">4</td> <td style="text-align: left"><strong>4.0</strong></td> <td style="text-align: left">~0.02 bits</td> <td style="text-align: left">0</td> <td style="text-align: left">Collapse</td> </tr> </tbody> </table> <p>When all tool definitions are introduced simultaneously into the model’s context, the system operates at \(\lambda \approx 4\). This is deep into the collapse zone.</p> <p><strong>Even a perfect tool selector achieves only ~0.02 bits of selectivity over random chance.</strong></p> <p>The LLM is essentially guessing. And as Anthropic notes: <strong>“The most common failures are wrong tool selection and incorrect parameters, especially when tools have similar names.”</strong> This perfectly reflects the 20 Newsgroups scenario when \(R_q\) (relevant-per query items) was large.</p> <h3 id="the-pattern-extends-beyond-tools">The Pattern Extends Beyond Tools</h3> <p>The collapse boundary doesn’t care what you’re selecting. It’s a property of the selection problem itself: \(\lambda = \frac{K \cdot \bar{R}_q}{N}\)</p> <p>When \(\lambda\) hits 3–5, selectivity collapses, whether you’re selecting:</p> <ul> <li>Documents from a corpus</li> <li>Tools from an API library</li> <li>Agentic “skills”</li> <li>Functions from hundreds of endpoints</li> <li>Context from multi-hop retrieval chains</li> </ul> <table> <thead> <tr> <th style="text-align: left">Scenario</th> <th style="text-align: left">N</th> <th style="text-align: left">\(R_q\)</th> <th style="text-align: left">K</th> <th style="text-align: left">\(\lambda = \frac{K \cdot R_q}{N}\)</th> <th style="text-align: left">Regime</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">RAG (typical)</td> <td style="text-align: left">10,000</td> <td style="text-align: left">1–2</td> <td style="text-align: left">10</td> <td style="text-align: left">~0.002</td> <td style="text-align: left">Healthy</td> </tr> <tr> <td style="text-align: left">Tool selection (filtered)</td> <td style="text-align: left">20</td> <td style="text-align: left">3</td> <td style="text-align: left">5</td> <td style="text-align: left">0.75</td> <td style="text-align: left">Healthy</td> </tr> <tr> <td style="text-align: left">Tool selection (show all)</td> <td style="text-align: left">20</td> <td style="text-align: left">3</td> <td style="text-align: left">20</td> <td style="text-align: left">3.0</td> <td style="text-align: left">Collapse</td> </tr> <tr> <td style="text-align: left">API endpoints (show half)</td> <td style="text-align: left">100</td> <td style="text-align: left">8</td> <td style="text-align: left">50</td> <td style="text-align: left">4.0</td> <td style="text-align: left">Collapse</td> </tr> <tr> <td style="text-align: left">Anthropic’s 58-tool example</td> <td style="text-align: left">58</td> <td style="text-align: left">4</td> <td style="text-align: left">58</td> <td style="text-align: left">4.0</td> <td style="text-align: left">Collapse</td> </tr> </tbody> </table> <p><strong>This is why agentic systems struggle with tool selection far more than RAG systems struggle with document retrieval.</strong> The math is unforgiving when N is small.</p> <h2 id="what-you-should-do-about-this">What You Should Do About This</h2> <p>BoR gives you a new lens for evaluating retrieval systems. It reveals when high success rates are actually warning signs.</p> <p><strong>1. Monitor the collapse boundary</strong></p> <p>Calculate \(\lambda = \frac{K \cdot \bar{R}_q}{N}\) for your system. When \(\lambda\) approaches 3–5, you’re entering the danger zone. This single number tells you whether selectivity is even possible.</p> <p><strong>2. Use BoR to guide your K selection</strong></p> <p>Don’t just crank up K to boost success metrics. Instead:</p> <ul> <li>Stop increasing K when \(\text{BoR}_{\text{max}}\) drops below ~0.1 bits.</li> <li>If \(\text{BoR} \approx \text{BoR}_{\text{max}}\), you’ve saturated and more K won’t help.</li> <li>If \(\Delta\text{BoR}\) becomes negative or negligible, you’re adding noise, not signal.</li> </ul> <p><strong>3. For tool-based agents: Be aggressive about filtering</strong></p> <p>With small N (50–500 tools), you can’t afford to dump everything into context. Use:</p> <ul> <li>Two-stage retrieval (filter, then select)</li> <li>Dynamic tool loading based on task context</li> <li>Clustering by function domain</li> </ul> <p><strong>4. Remember the core insight</strong></p> <p><strong>More context is not always better.</strong> High Success@K can coexist with zero selectivity.</p> <table> <thead> <tr> <th style="text-align: left">Scenario</th> <th style="text-align: left">Calculations</th> <th style="text-align: left">Conclusion</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"> <strong>K → N</strong> (K tends to N)</td> <td style="text-align: left">N = 100, K = 100, \(R_q = 1\)<br><br>\(P_{\text{obs}} = 1.0\) (retrieve everything, guaranteed success)<br><br>\(P_{\text{rand}} = 1.0\) (random selection of all 100 items → also guaranteed success)<br><br>\(\text{BoR} = \log_2(1.0 / 1.0) = 0\) bits exactly</td> <td style="text-align: left"> <strong>BoR → 0 when K → N</strong> (K is closer to N)<br><br>Both Recall and Success@K are perfect. But BoR approaches zero asymptotically.<br><br>At K = N, BoR = 0.</td> </tr> <tr> <td style="text-align: left"> <strong>Bad retriever</strong> - deliberately omits relevant results</td> <td style="text-align: left">N = 100, K = 10, \(R_q = 1\)<br><br>\(P_{\text{rand}} = 10/100 = 0.10\) (random succeeds 10% of the time)<br><br>retriever is adversarially bad: \(P_{\text{obs}} = 0.05\)<br><br>\(\text{BoR} = \log_2(0.05 / 0.10) = \log_2(0.5) = -1\) bit</td> <td style="text-align: left"> <strong>BoR &lt; 0</strong> means we are actively avoiding relevant documents, doing worse than chance.</td> </tr> </tbody> </table> <h2 id="sidebar-successk-vs-recallk">Sidebar: Success@K vs Recall@K</h2> <p>Some readers might wonder: this post focuses on Success@K (coverage), but what about Recall@K?</p> <table> <thead> <tr> <th style="text-align: left">Metric</th> <th style="text-align: left">What It Measures</th> <th style="text-align: left">Per-Query Behavior</th> <th style="text-align: left">Best For</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>Success@K</strong></td> <td style="text-align: left">Did you get \(\geq 1\) relevant item?</td> <td style="text-align: left">Binary: success or fail</td> <td style="text-align: left">RAG/QA where one good context suffices</td> </tr> <tr> <td style="text-align: left"><strong>Recall@K</strong></td> <td style="text-align: left">What fraction of all relevant items did you get?</td> <td style="text-align: left">Graded: 0% to 100%</td> <td style="text-align: left">Tasks needing comprehensive coverage</td> </tr> </tbody> </table> <p>The good news: <strong>BoR works with both.</strong></p> <h3 id="bor-for-recallk">BoR for Recall@K</h3> <p>The same framework applies. Instead of measuring “probability of \(\geq 1\) hit,” you measure “expected fraction retrieved”:</p> \[\text{BoR}_{\text{recall@K}} = \log_2\left(\frac{\text{observed_recall@K}}{\text{expected_recall@K_random}}\right)\] <p>For sparse relevance: \(\text{expected_recall@K_random} \approx \frac{K}{N}\)</p> <p><strong>Example:</strong> A query has 10 relevant items in a 1,000-document corpus. You retrieve 4 in top-20:</p> <ul> <li>Observed recall = \(\frac{4}{10} = 0.4\)</li> <li>Random baseline = \(\frac{20}{1{,}000} = 0.02\)</li> <li>\(\text{BoR}_{\text{recall@K}} = \log_2\left(\frac{0.4}{0.02}\right) = \log_2(20) \approx\) <strong>4.32 bits</strong> </li> </ul> <h3 id="math-and-bor-interpretation">Math and BoR Interpretation</h3> <table> <thead> <tr> <th style="text-align: left">Metric</th> <th style="text-align: left">Definition</th> <th style="text-align: left">Formula</th> <th style="text-align: left">Observed Rate</th> <th style="text-align: left">Expected Rate (Random)</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>BoR for Success@K</strong></td> <td style="text-align: left">Bits-over-Random for coverage (\(\geq 1\) relevant)</td> <td style="text-align: left">\(\log_2\left(\frac{\text{observed_success}}{\text{expected_success_random}}\right)\)</td> <td style="text-align: left">Fraction of queries with \(\geq 1\) relevant in top-K</td> <td style="text-align: left">Probability of \(\geq 1\) hit by random selection</td> </tr> <tr> <td style="text-align: left"><strong>BoR for Recall@K</strong></td> <td style="text-align: left">Bits-over-Random for recall (fraction retrieved)</td> <td style="text-align: left">\(\log_2\left(\frac{\text{observed_recall@K}}{\text{expected_recall@K_random}}\right)\)</td> <td style="text-align: left">Average fraction of relevant items in top-K</td> <td style="text-align: left">Expected fraction if picking K random (usually \(\frac{K}{N}\))</td> </tr> </tbody> </table> <p>The depth-calibrated identity also extends to Recall@K, with minor adjustments for the different success rule.</p> <p>We focus on Success@K in this post because it matches the most common RAG use case: you just need <em>one</em> good grounding passage.</p> <h2 id="final-thoughts">Final Thoughts</h2> <p>Retrieval evaluation has been stuck with metrics designed for human consumers. RAG and agentic AI systems need something different, something that accounts for the fact that every retrieved item imposes a cost, and random chance sets a floor.</p> <p><strong>Bits-over-Random provides that measure.</strong></p> <p>It makes three things visible that were previously hidden:</p> <ol> <li> <strong>The ceiling:</strong> Even perfect systems have limited selectivity when random baselines are high</li> <li> <strong>The collapse zone:</strong> When \(\lambda = \frac{K \cdot \bar{R}_q}{N}\) reaches 3–5, selectivity becomes impossible</li> <li> <strong>The depth trade-off:</strong> Retrieving more doesn’t always help and it can actively hurt</li> </ol> <p>The math is simple but the implications are profound.</p> <p>When your tool-based agent has 50 functions available, and you dump all 50 into context, you’re not being thorough, you’re operating in the collapse zone. BoR reveals that.</p> <p>When you boost Success@K from 95% to 100% by tripling K, traditional metrics celebrate. BoR shows you just lost 1.5 bits of selectivity.</p> <p>The systems that win in the next era of AI won’t be the ones that retrieve the most. They’ll be the ones that retrieve the most <strong>selectively</strong>.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/2026/assets/bibliography/2026-04-27-bits-over-random.bib"></d-bibliography> <d-article> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-reversal-curse-from-general-domain-to-remote-sensing-images/">Visual Reversal Curse: From General Domain to Remote Sensing Images</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-long-context/">Text-as-Image, A Visual Encoding Approach for Long-Context Understanding</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/vis-llm-latent-geometry/">Visualizing LLM Latent Space Geometry Through Dimensionality Reduction</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/unigramlm-manual/">UnigramLM - An Attempt at Writing the Missing Manual</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/symbolic-connect/">From Dense Monoliths to Modular Minds: The Rise of Symbolic Routing in LLMs</a> </li> <br> <br> </d-article> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 ICLR Blog. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/2026/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/2026/assets/js/distillpub/overrides.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/2026/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/2026/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/2026/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/2026/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/2026/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/2026/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/2026/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/2026/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/2026/assets/js/search-data.js"></script> <script src="/2026/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>