<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Is your algorithm Unlearning or Untraining? | ICLR Blogposts 2026 </title> <meta name="author" content="ICLR Blog"> <meta name="description" content="Machine unlearning aims to post-process a trained model in order to remove the influence of specific training examples or higher-level knowledge. We argue that the term unlearning is overloaded, with different use cases belonging to distinct problem formulations. This issue causes confusion in the community: it is often unclear what the goals of different proposed methods are, when they are expected to work, how they should be evaluated, and what baselines they should be compared against. To address this, we establish a fundamental distinction between two notions that we identify as Unlearning and Untraining, aiming to guide the field towards disambiguating technical definitions, to unlock more progress in clarifying goals, designing evaluation metrics for each, and ultimately better algorithms."> <meta name="keywords" content="machine-learning, ml, deep-learning, reinforcement-learning, icl# add your own keywords or leave empty"> <link rel="stylesheet" href="/2026/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/2026/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/2026/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/2026/assets/img/iclr_favicon.ico?0a8a3afdb0dbe139723b24dba3052a4f"> <link rel="stylesheet" href="/2026/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://iclr-blogposts.github.io/2026/blog/2026/unlearning-or-untraining/"> <script src="/2026/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/2026/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/2026/assets/js/distillpub/template.v2.js"></script> <script src="/2026/assets/js/distillpub/transforms.v2.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Is your algorithm Unlearning or Untraining?",
            "description": "Machine unlearning aims to post-process a trained model in order to remove the influence of specific training examples or higher-level knowledge. We argue that the term unlearning is overloaded, with different use cases belonging to distinct problem formulations. This issue causes confusion in the community: it is often unclear what the goals of different proposed methods are, when they are expected to work, how they should be evaluated, and what baselines they should be compared against. To address this, we establish a fundamental distinction between two notions that we identify as Unlearning and Untraining, aiming to guide the field towards disambiguating technical definitions, to unlock more progress in clarifying goals, designing evaluation metrics for each, and ultimately better algorithms.",
            "published": "April 27, 2026",
            "authors": [
              
              {
                "author": "Anonymous",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/2026/"> ICLR Blogposts 2026 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/2026/">home </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/about/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/call/">call for blogposts </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/submitting/">submitting </a> </li> <li class="nav-item "> <a class="nav-link" href="/2026/reviewing/">reviewing </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">past iterations </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2026/"><strong>2026</strong></a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2025/">2025</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2024/">2024</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blogposts.github.io/2023/">2023</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="https://iclr-blog-track.github.io/home/" rel="external nofollow noopener" target="_blank">2022</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Is your algorithm Unlearning or Untraining?</h1> <p>Machine unlearning aims to post-process a trained model in order to remove the influence of specific training examples or higher-level knowledge. We argue that the term unlearning is overloaded, with different use cases belonging to distinct problem formulations. This issue causes confusion in the community: it is often unclear what the goals of different proposed methods are, when they are expected to work, how they should be evaluated, and what baselines they should be compared against. To address this, we establish a fundamental distinction between two notions that we identify as Unlearning and Untraining, aiming to guide the field towards disambiguating technical definitions, to unlock more progress in clarifying goals, designing evaluation metrics for each, and ultimately better algorithms.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#training-and-learning">Training and learning</a> </div> <div> <a href="#memorization">Memorization</a> </div> <div> <a href="#machine-unlearning-the-classic-definition">Machine "unlearning": the classic definition</a> </div> <div> <a href="#distinguishing-un-training-from-un-learning">Distinguishing Un-training from Un-learning</a> </div> <div> <a href="#unlearning-of-definition-2-is-actually-untraining">'Unlearning' of Definition 2 is actually Untraining</a> </div> <div> <a href="#defining-unlearning">Defining Unlearning</a> </div> <div> <a href="#mapping-untraining-and-unlearning-to-the-literature">Mapping Untraining and Unlearning to the literature</a> </div> <div> <a href="#limitations">Limitations</a> </div> <div> <a href="#conclusion-and-outlook">Conclusion and outlook</a> </div> </nav> </d-contents> \[\newcommand{\alg}{\mathcal{A}} \newcommand{\unlearn}{\mathcal{U}} \newcommand{\loss}{\ell} \newcommand{\dataset}{\mathcal{D}} \newcommand{\forgetset}{\mathcal{S}} \newcommand{\retainset}{\mathcal{D} \setminus \mathcal{S}}\] <h2 id="introduction">Introduction</h2> <p>“Unlearning” was first coined by <d-cite key="cao2015towards"></d-cite>, who envisioned systems that are “capable of forgetting certain data and their lineages, completely and quickly”. Since then, there has been an explosion of work on the topic. Most early work on “unlearning” was motivated by the need to enable users to revoke access to their personal data that may have already been used to train machine learning models <d-cite key="neel2021descent,sekhari2021remember,golatkar2020eternal,bourtoule2021machine,golatkar2020forgetting,thudi2022unrolling"></d-cite>. However, more recently, several works propose methods that use “unlearning” for a wider range of use cases, including removing dangerous “knowledge” that could e.g. aid a malicious actor to develop biological, cyber, and chemical weapons <d-cite key="li2024wmdp"></d-cite>, removing harmful “capabilities” or “concepts” to make models safer <d-cite key="liu2024towards,yao2024large,lucki2024adversarial,barez2025open,zhang2024forget,lynch2024eight,fan2023salun"></d-cite>, erasing backdoors <d-cite key="liu2022backdoor"></d-cite>, eliminating poisoning attacks <d-cite key="schoepf2024potion,schoepf2025redirection,pawelczyk2024machine"></d-cite>, or unlearning copyrighted content like the “Harry Potter” books <d-cite key="eldan2023s,shi2024muse"></d-cite> or specific artistic styles <d-cite key="zhang2024unlearncanvas,fan2023salun"></d-cite>.</p> <p>In the following sections, we will review important background and define key notions of training, learning, and memorization. We will then make a novel distinction between two notions that we refer to as <em>Un</em> <strong>learning</strong> and <em>Un</em> <strong>training</strong>, establishing appropriate vocabulary for distinguishing the problem settings that correspond to different use cases studied in the literature. We will provide a technical definition for each of <em>Un</em> <strong>learning</strong> and <em>Un</em> <strong>training</strong>, drawing from previously-proposed notions from the literature for the latter. We will discuss how the solutions to these two problem settings differ through illustrative examples, and we will close by discussing important research questions that we hope future work pursues.</p> <h2 id="training-and-learning">Training and learning</h2> <p>To set the scene for discussing the distinction between <em>Un</em> <strong>training</strong> and <em>Un</em> <strong>learning</strong>, lets first revisit the definitions of training and learning, and related concepts of generalization and memorization.</p> <p><strong>Training</strong>, from a statistical learning theory perspective <d-cite key="vapnik2013nature"></d-cite>, can be defined as the process of obtaining a function that minimizes empirical risk on a finite dataset $\mathcal{D}$, which generally involves solving an optimization problem. For parametric functions like neural networks, the goal of training algorithm $\mathcal{A}$ is to find a set of parameters $\theta$ that minimizes the error on a specific finite set of data $\mathcal{D}$.</p> <p><strong>Learning</strong>, on the other hand, involves reducing expected risk on the underlying data distribution via training i.e., reducing the empirical risk on a finite dataset $\mathcal{D}$. In this sense, learning is synonymous with generalization – the ability of making correct predictions on the underlying distribution of data, including unseen data, rather than just $\mathcal{D}$.</p> <p><strong>Training does not always lead to Learning.</strong> In fact, there is a vast literature exploring the design of training algorithms that optimally result in learning, e.g., optimization techniques like sharpness aware minimization <d-cite key="foret2021sharpnessaware"></d-cite> that use the loss landscape geometry to reach a flatter minima, techniques like MixUp <d-cite key="zhang2017mixup"></d-cite> that improve generalization by augmenting the training data with convex combinations of samples, and regularization techniques like spectral normalization of parameters <d-cite key="miyato2018spectral"></d-cite> that improves Lipschitz continuity of the learned function.</p> <p>Recent work, has demonstrated that training can even lead to risk minimization only on the training data $\mathcal{D}$ without learning <d-cite key="power2022grokking,liu2023omnigrok,humayun2024grok"></d-cite>. This behavior occurs alongside a training dynamics phenomenon termed <em>grokking</em>, where deep networks tend to <strong>memorize</strong> the labels for the training data but perform poorly for a held out dataset from the underlying data distribution—until a large number of training iterations. The discussion from above points to one important finding—a finite training dataset $\mathcal{D}$ may or may not influence the behavior of the obtained function for samples that are not in $\mathcal{D}$. Furthermore, as we discuss in the next section, different examples influence the model differently during training and have different consequences for learning.</p> <h2 id="memorization">Memorization</h2> <p>The way in which different examples influence the function obtained via training, remains an active area of research <d-cite key="jaeckel1972infinitesimal,koh2017understanding,pruthi2020estimating"></d-cite>. A phenomenon that has been studied extensively is the fact that training can lead to <strong>memorization</strong> of certain examples from $\mathcal{D}$. <d-cite key="feldman2020does,zhang2023counterfactual"></d-cite> define a notion of counterfactual memorization, where the memorization score for a training example is given as follows.</p> <blockquote> <p><strong>Definition 1 (Memorization score).</strong> <d-cite key="feldman2020does"></d-cite> <a name="defn:mem"></a> The <em>memorization score</em> for an example $i \in \dataset$, with respect to a training dataset $\dataset$ and training algorithm $\alg$ is</p> \[\text{mem}(\alg, \dataset, i) = \Pr_{f \sim \alg(\dataset)}[f(x_i) = y_i] \ - \Pr_{f \sim \alg(\dataset \setminus i)}[f(x_i) = y_i]\] <p>where $x_i$ and $y_i$ are the feature and label, respectively, of example $i$.</p> </blockquote> <p>The first term in the above equation considers models trained on all of $\dataset$ whereas the second term considers models trained on $\dataset$ excluding example $i$. Intuitively, the memorization score for an example $i$ is high if including it in training results in a different distribution of predictions on that example compared to excluding it from training. <d-footnote>While the above definition assumes a classification problem, a more general notion of <em>counterfactual memorization</em> has been proposed in <d-cite key="zhang2023counterfactual"></d-cite> that can be applied to Large Language Models (LLMs) or other generative models. All arguments made in this blog post hold for any type of architecture and training algorithm.</d-footnote></p> <p>Recent works <d-cite key="feldman2020does,feldman2020neural,jiang2020characterizing"></d-cite> find that outliers or noisy, e.g. mislabeled, data points are more highly memorized, since these are examples that would not have been predicted correctly unless they were part of the training dataset. For example, in a classification task, imagine a training example that is an image of a cat being labeled as a chair. During training, the model can fit this strange data point and predict its assigned label of chair. However, had this example been excluded from the training set, the model would not predict that this cat image is a chair. This discrepancy, between the prediction on this data point of models that included it in training, compared to models that excluded it from training, leads to this data point being highly memorized according to Definition 1.</p> <p>Generally, the interaction between memorization and learning is an important active area of research, with theory works advocating that some memorization is even necessary for learning <d-cite key="feldman2020does,attias2024information"></d-cite>. However, while memorization is sometimes needed, it is also sometimes unwanted, as it may cause vulnerability to membership inference attacks or data extraction attacks <d-cite key="shokri2017membership,carlini2022membership,carlini2021extracting"></d-cite>.</p> <h2 id="machine-unlearning-the-classic-definition">Machine “unlearning”: the classic definition</h2> <p>Before we introduce the distinction between <em>Un</em> <strong>learning</strong> and <em>Un</em> <strong>training</strong>, let us first describe the classic problem formulation of “unlearning”, which was motivated by the need to remove memorized examples or to enable users to request their data to be deleted from machine learning models.</p> <p>Let $\alg(\dataset)$ denote the weights of a model obtained by applying learning algorithm $\alg$ on dataset $\dataset$; we refer to this as the “original model”. Informally, according to the classic definition of machine unlearning, the goal is to remove the influence of a forget set $\forgetset \subset \dataset$ from the weights of the original model.</p> <p>A straightforward solution for this problem is to simply retrain a model from scratch on an adjusted training set that excludes $\forgetset$, referred to as the “retain set”. The ideal solution is therefore $\alg(\retainset)$. However, retraining from scratch is inefficient, especially for larger models. To address this, the goal of unlearning is to avoid throwing away the original model and instead devise an efficient algorithm $\unlearn$ that can post-process it to produce an unlearned model $\unlearn(\alg(\dataset), \forgetset, \dataset)$ that approximates the ideal solution of having trained from scratch.</p> <p>Variations of technical definitions have been proposed that formalize this intuition <d-cite key="sekhari2021remember,gupta2021adaptive,neel2021descent"></d-cite>, drawing inspiration from differential privacy <d-cite key="dwork2006differential"></d-cite>.</p> <blockquote> <p><strong>Definition 2 (($\varepsilon$, $\delta$)-unlearning).</strong> <d-cite key="neel2021descent"></d-cite> <a name="defn:classic_unlearning"></a> For a fixed randomized learning algorithm $\alg$, an unlearning algorithm $\unlearn$ is $(\varepsilon,\delta)$-unlearning with respect to $\alg$ if for any dataset $\dataset$, forget set $\forgetset \subset \dataset$, it holds that for all $R \subseteq \mathcal{R}$ we have:</p> \[\begin{aligned} \Pr[\alg(\retainset) \in R] &amp;\le e^\varepsilon \Pr[\unlearn(\alg(\dataset), \forgetset, \dataset) \in R] + \delta, \quad \mathrm{and} \\ \Pr[\unlearn(\alg(\dataset), \forgetset, \dataset) \in R] &amp;\le e^\varepsilon \Pr[\alg(\retainset) \in R] + \delta. \end{aligned}\] <p>where $\mathcal{R}$ denotes the output space, in this case, the space of model parameters.</p> </blockquote> <p>Measuring success of unlearning according to this definition requires estimating how close two distributions are to one another: the distribution of $\unlearn(\alg(\dataset), \forgetset, \dataset)$ and that of $\alg(\retainset)$. We refer to distributions here since running $\alg$ and $\unlearn$ with different random seeds that control, for instance, the initialization and order of mini-batches, will yield slightly different model weights each time. <d-cite key="triantafillou2024we,hayes2024inexact,kurmanji2024towards,pawelczyk2023context"></d-cite> discuss this issue of evaluation in more depth and propose rigorous evaluation procedures for this definition.</p> <p>We will later argue that this classic definition of unlearning is better described as <em>Un</em> <strong>training</strong>. We will contrast it below with a different definition of the problem, which we will refer to as <em>Un</em> <strong>learning</strong>.</p> <h2 id="distinguishing-untraining-from-unlearning">Distinguishing <em>Un</em> <strong>training</strong> from <em>Un</em> <strong>learning</strong> </h2> <p>In this section, we present our main contribution: disentangling two problem formulations that are currently both referred to as “unlearning” in the literature.</p> <ul> <li> <p>As <strong>training</strong> is about minimizing empirical risk on a finite dataset $\dataset$, <em>Un</em> <strong>training</strong> on $\forgetset \subset \dataset$ is the process of reversing the empirical risk minimization on $\forgetset$. In other words, the ideal solution to <em>Un</em> <strong>training</strong> is to find the model parameters minimizing empirical risk on only $\retainset$.</p> </li> <li> <p>On the other hand, <strong>learning</strong> and <em>Un</em> <strong>learning</strong> are both about generalization (inducing it, and removing it, respectively). <em>Un</em> <strong>learning</strong> a pattern, “concept” or “behaviour” from a given representative forget set $\forgetset$ is to generalize the removal beyond the specific examples in $\forgetset$, to approximate a model that was never trained on <em>any</em> instance of the pattern.</p> </li> </ul> <p>Notice that <em>Un</em> <strong>training</strong> a forget set $\forgetset$ does not mean that the model is unable to predict the examples of $\forgetset$ correctly. A model trained purely on $\retainset$ may still be able to predict the examples of $\forgetset$ correctly due to generalization. On the other hand, <em>Un</em> <strong>learning</strong> a pattern, concept or “behaviour” from a forget set $\forgetset$ would make the model unable to predict the examples of $\forgetset$ any better than a model that never trained on <em>any</em> instances of the concept (i.e. a model that never learned the concept).</p> <p>We illustrate the difference between <em>Un</em> <strong>training</strong> versus <em>Un</em> <strong>learning</strong>, for a given forget set $\forgetset$ in Figure 1.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/2026/assets/img/2026-04-27-unlearning-or-untraining/figure1-480.webp 480w,/2026/assets/img/2026-04-27-unlearning-or-untraining/figure1-800.webp 800w,/2026/assets/img/2026-04-27-unlearning-or-untraining/figure1-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/2026/assets/img/2026-04-27-unlearning-or-untraining/figure1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> <strong>Figure 1. Illustration of the difference between <em>Un</em> <strong>learning</strong> and <em>Un</em> <strong>training</strong>, using a given forget set $\forgetset$.</strong> The different shapes correspond to data points in a dataset $\dataset$. A shape is coloured white if the model predicts it correctly and black otherwise. In the middle of the figure, we depict the predictions of the original model that was trained on all of $\dataset$, before any <em>Un</em> <strong>learning</strong> or <em>Un</em> <strong>training</strong> is carried out. This model predicts correctly on all of its training set. On the left, we show the predictions of the model obtained by <em>Un</em> <strong>training</strong> $\forgetset$, which matches the behaviour of a model trained on $\dataset \setminus \forgetset$ -- i.e. a model trained on all of the data points except for the star and the two circles that belong to the forget set $\forgetset$. Notice that the untrained model still predicts the circles correctly. This is because there are several other circles in the remaining dataset from where the model trained on $\dataset \setminus \forgetset$ can learn about circles. On the other hand, the star that was in the forget set is no longer predicted correctly, as there are fewer other stars in the dataset. On the right, we show the predictions of the model obtained by <em>Un</em> <strong>learning</strong> the "behaviour" underlying $\forgetset$, where the "behaviour" in this case is "being a circle or a star". The unlearned model makes incorrect predictions on <em>all</em> examples of that behaviour. </div> <h2 id="unlearning-of-definition-2-is-actually-untraining">“Unlearning” of Definition 2 is actually <em>Un</em> <strong>training</strong> </h2> <p>Let’s take a closer look at Definition 2. According to this definition, the ideal unlearning algorithm produces a model that is indistinguishable (in distribution) from one retrained from scratch on the retain set $\mathcal{D} \setminus \mathcal{S}$. Notably, this means that it is not the case that the ideal “unlearned” model is unable to predict correctly on the forget set (nor on examples that are similar to the forget set).</p> <p>In other words, “unlearning”, according to this definition, is not about removing all knowledge about the forget set (and related examples); it’s about removing only the <em>additional</em> knowledge about the forget set that existed only <em>due to having trained on the forget set</em>.</p> <p>Let’s take as an example the case where $\mathcal{S}$ consists of non-memorized examples (more precisely, examples with low “memorization scores” according to Definition 1). We assume the original model $\mathcal{A}(\mathcal{D})$ predicts the examples of $\mathcal{S}$ correctly; a reasonable assumption given $\mathcal{S} \subset \mathcal{D}$. Now, the fact that the examples in $\mathcal{S}$ are not memorized means that the retrained-from-scratch model $\mathcal{A}(\mathcal{D \setminus S})$ also predicts the examples of $\mathcal{S}$ correctly. This means that the classic definition of “unlearning” (where retrain-from-scratch is the ideal “unlearning” algorithm), wants the “unlearned” model to still predict the examples of $\mathcal{S}$ correctly, effectively necessitating no change over the original model. <d-footnote>This observation has been previously made by <d-cite key="zhao2024makes"></d-cite>, who also studies how existing unlearning algorithms perform on forget sets of different degrees of memorization.</d-footnote><d-footnote>Note a nuance about a mismatch between the unlearning definition referring to model weights whereas the memorization definition referring to model outputs. This is to comply with prior work that defines these notions; we leave it to future work to address this minor inconsistency.</d-footnote> An example of this phenomenon is given by the circles that are present in $\forgetset$ in Figure 1: the ideal <em>Un</em> <strong>training</strong> solution is still able to predict circles correctly. In the next section, we will discuss a different problem formulation, that we will refer to as <em>Un</em> <strong>learning</strong>, where this will no longer be the case.</p> <h2 id="defining-unlearning">Defining <em>Un</em> <strong>learning</strong> </h2> <p>We now define our notion of <em>Un</em> <strong>learning</strong> a “concept” or “behaviour” from a trained model. Unlike <em>Un</em> <strong>training</strong> where the goal is simply to remove the influence that the specific forget set had on the model, here we aim to generalize the removal beyond the given forget set, towards entirely removing the concept or behaviour that the forget set represents. We sketch a definition of this below.</p> <blockquote> <p><strong>Definition 3 (<em>Un</em> </strong>learning<strong>).</strong> <a name="defn:actual_unlearning"></a> For a dataset $\dataset$, let $\forgetset^{full} \subset \dataset$ be the complete set of examples of $\dataset$ that capture a behaviour $\mathcal{B}$. Let $\forgetset \subseteq \forgetset^{full}$ denote the forget set that contains some examples of $\mathcal{B}$. Then, for a fixed randomized learning algorithm $\alg$, an <em>Un</em> <strong>learning</strong> algorithm $\unlearn$ is one such that $\unlearn(\alg(\dataset), \forgetset, \dataset)$ is indistinguishable (in distribution) from $\alg(\dataset \setminus \forgetset^{full})$.</p> </blockquote> <p>We make the following remarks about this definition.</p> <ol> <li>Indistinguishability can be defined in different ways, e.g. through the Hockey-stick divergence, similar to Definition 2, but other divergences are also possible. We purposefully keep this abstract in this blog post.</li> <li>This is a conceptual definition to illustrate the notion of <em>Un</em> <strong>learning</strong> (contrasting it to the notion of <em>Un</em> <strong>training</strong>), but in practice we may not be able to specify the set $\forgetset^{full}$ containing every instantiation of a behaviour in a given dataset.</li> <li>When $\forgetset$ is very small, relative to $\forgetset^{full}$, this may be referred to as “few-shot” <em>Un</em> <strong>learning</strong> <d-cite key="yoon2024few,de2024unlearning"></d-cite>.</li> <li>When $\forgetset$ includes all training instances of $\mathcal{B}$, the <em>Un</em> <strong>training</strong> $\forgetset$ and <em>Un</em> <strong>learning</strong> $\mathcal{B}$ are one and the same.</li> </ol> <p>Notice that the definition of <em>Un</em> <strong>learning</strong> has an element of generalization: from the specific forget set $\forgetset$ showcasing a “behaviour” $\mathcal{B}$, <em>Un</em> <strong>learning</strong> <em>generalizes</em> to removing <em>all</em> knowledge of $\mathcal{B}$, beyond $\forgetset$; analogously to how learning from a specific set of examples also leads to generalization in the sense of acquiring broader knowledge beyond the given set of examples. This is the key aspect that distinguishes <em>Un</em> <strong>learning</strong> from <em>Un</em> <strong>training</strong>. And this generalization of knowledge removal is crucial for removing unwanted behaviours from models, as in practice it’s not possible to specify every possible instantiation of a behaviour $\mathcal{B}$ in $\mathcal{S}$.</p> <p>Let’s now discuss how, for the same forget set $\mathcal{S}$, the solutions of <em>Un</em> <strong>training</strong> and <em>Un</em> <strong>learning</strong> will (in general) be different. Let’s revisit our scenario from before where $\forgetset$ contains only non-memorized examples of the target “behaviour” $\mathcal{B}$. In that case, the solution to <em>Un</em> <strong>training</strong> would be to not take any action, leaving the model as is. On the other hand, the solution to <em>Un</em> <strong>learning</strong> would be quite different, as a large modification would be required in this case to approximate a model $\alg(\forgetset^{full})$ that never trained on <em>any</em> example of the behaviour that $\forgetset$ represents.</p> <h2 id="mapping-untraining-and-unlearning-to-the-literature">Mapping <em>Un</em> <strong>training</strong> and <em>Un</em> <strong>learning</strong> to the literature</h2> <p><strong>Examples of <em>Un</em> </strong>training<strong>.</strong> The most prominent example, which was a key motivation behind several “unlearning” (more accurately, <em>Un</em> <strong>training</strong>) works, is that of protecting user privacy, by honoring users’ requests to delete their data from models <d-cite key="neel2021descent,sekhari2021remember,golatkar2020eternal,bourtoule2021machine,golatkar2020forgetting,thudi2022unrolling"></d-cite>. Another example is removing data points that are mislabeled, outdated, or noisy <d-cite key="kurmanji2024towards,goel2022towards"></d-cite>. Finally, “unlearning” (more accurately <em>Un</em> <strong>training</strong>) specific data points from LLMs <d-cite key="jang2023knowledge,barbulescu2024each"></d-cite> or from diffusion models <d-cite key="alberti2025data"></d-cite> are also applications that fall into this category, that may be useful to address either privacy or copyright issues.</p> <p><strong>Examples of <em>Un</em> </strong>learning<strong>.</strong> There are several recent examples of <em>Un</em> <strong>learning</strong> in the literature, including <em>Un</em> <strong>learning</strong> dangerous knowledge or capabilities <d-cite key="li2024wmdp,liu2024towards,lynch2024eight"></d-cite> <d-footnote>Recent research in LLMs is conducted on top of large pretrained models, where we don't have control of the training set and we don't have knowledge of which training examples gave rise to different "behaviours". It's possible that the forget sets used aren't even part of the training set. We can accordingly also broaden [Definition 3](#defn:actual_unlearning) to consider $\forgetset$ that isn't necessarily part of $\mathcal{D}$.</d-footnote>, erasing backdoors <d-cite key="liu2022backdoor"></d-cite>, or concepts like “not safe for work” <d-cite key="fan2023salun,zhang2024forget"></d-cite>. The notion of “corrective unlearning” <d-cite key="goel2024corrective"></d-cite> is also a type of <em>Un</em> <strong>learning</strong>: the goal is to remove a “corruption” or poison from partial discovery of the training data that cause the corruption or poison. This topic is enjoying increasing attention recently <d-cite key="schoepf2024potion,schoepf2025redirection"></d-cite>. Similarly, <em>Un</em> <strong>learning</strong> an “artistic style” from some examples of that style is falls into this category <d-cite key="fan2023salun,zhang2024unlearncanvas"></d-cite>. Finally, <em>Un</em> <strong>learning</strong> of “classes” fits into this category too, e.g. <d-cite key="golatkar2020eternal,kurmanji2024towards,shah2023unlearning"></d-cite>. <d-footnote>While most works do class unlearning via *Un* **training**, since on small benchmark datasets the set $\forgetset^{full}$ of examples belonging to a target class is known. But a compelling alternative formulation that is perhaps more realistic would be *Un* **learning** of a class via a strict subset of its examples.</d-footnote></p> <p>These are non-exhaustive lists to illustrate how use cases studied in the literature fit within our framework. We invite researchers to reflect on whether their work falls under <em>Un</em> <strong>learning</strong> or <em>Un</em> <strong>training</strong>.</p> <h2 id="limitations">Limitations</h2> <p>Our goal in this blog post is not a complete taxonomy of unlearning algorithms; we refer the reader to existing surveys for this <d-cite key="nguyen2022survey"></d-cite>. Similarly, we don’t attempt to discuss potential failure modes of unlearning methodology for different use cases <d-cite key="cooper2024machine,shumailov2024ununlearning"></d-cite>. Instead, our contribution is to establish one important, yet previously overlooked, axis that differentiates unlearning problems from one other: the fundamental distinction between <em>Un</em> <strong>learning</strong> and <em>Un</em> <strong>training</strong>. Other dimensions discussed in prior work, such as differentiating “deleting” knowledge from “suppressing” knowledge <d-cite key="hu2024unlearning,deeb2024unlearning,siddiqui2025dormant,che2025model"></d-cite>, are orthogonal to our definitions.</p> <p>We also note that not all possible “concepts” can be unlearned using our definition of <em>Un</em> <strong>learning</strong>. The concepts or behaviours that are in scope are those that can be specified through a set of examples $\forgetset$. Other concepts that don’t have that property, such as, for example, the concept of edge detection, necessitate different definitions and are out of scope of this work.</p> <h2 id="conclusion-and-outlook">Conclusion and outlook</h2> <p>We have argued that the term “unlearning” has been overloaded, with work falling under that umbrella spanning two distinct problem formulations, that we identify as <em>Un</em> <strong>learning</strong> and <em>Un</em> <strong>training</strong>. We establish the fundamental distinction between <em>Un</em> <strong>learning</strong> and <em>Un</em> <strong>training</strong>, aiming to initiate a discussion on technical formulations of “unlearning” for different use cases, clarify their goals, and interpret the expectations and failure modes associated with existing “unlearning” algorithms. We hope the field now <em>Un</em> <strong>learns</strong> the previous terminology and adopts our proposed conceptual framework for definitions that go beyond mere <em>Un</em> <strong>training</strong>.</p> <p>This conceptual distinction gives rise to several important research questions that we hope future work pursues, including (i) Which existing “unlearning” algorithms are better suited for <em>Un</em> <strong>training</strong> compared to <em>Un</em> <strong>learning</strong>? (ii) How large does $\forgetset$ need to be relative to $\mathcal{S}^{full}$ for unlearning to succeed? In what ways does the answer to the previous question depend on the <em>Un</em> <strong>learning</strong> algorithm, and the behaviour $\mathcal{B}$? (iii) Having clarified the goals for <em>Un</em> <strong>learning</strong>, can we devise novel algorithms with appropriate inductive biases for <em>Un</em> <strong>learning</strong> a concept from few examples, perhaps drawing inspiration from algorithms developed for <em>learning</em> from few examples?</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/2026/assets/bibliography/2026-04-27-unlearning-or-untraining.bib"></d-bibliography> <d-article> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/fans/">FANS - Frequency-Adaptive Noise Shaping for Diffusion Models</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-reversal-curse-from-general-domain-to-remote-sensing-images/">Visual Reversal Curse: From General Domain to Remote Sensing Images</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/visual-long-context/">Text-as-Image, A Visual Encoding Approach for Long-Context Understanding</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/vis-llm-latent-geometry/">Visualizing LLM Latent Space Geometry Through Dimensionality Reduction</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/2026/blog/2026/unigramlm-manual/">UnigramLM - An Attempt at Writing the Missing Manual</a> </li> <br> <br> </d-article> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 ICLR Blog. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/2026/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/2026/assets/js/distillpub/overrides.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/2026/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/2026/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/2026/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/2026/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/2026/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/2026/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/2026/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/2026/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/2026/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/2026/assets/js/search-data.js"></script> <script src="/2026/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>